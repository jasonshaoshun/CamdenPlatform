<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Tensor</name></assembly>
<members>
<member name="M:Tensor.HDF5.Write``1(System.String,``0[],Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Write data array to HDF5 file.</summary>
 <typeparam name="'T">Type of the data.</typeparam>
 <param name="name">HDF5 path to write to.</param>
 <param name="data">Data array to write.</param>
 <param name="shape">Array shape to use.</param>
 <remarks>All HDF5 groups are automatically created as necessary.</remarks>
 <seealso cref="Read``1"/><seealso cref="HostTensor.write"/>
</member>
<member name="M:Tensor.HDF5.SplitPath(System.String)">
<summary>
 Splits a HDF5 path string into a list.
</summary>
</member>
<member name="M:Tensor.HDF5.SetRecord``1(System.String,``0)">
 <summary>Set attribute values on an HDF5 object using the provided record.</summary>
 <typeparam name="'R">Type of the F# record. It must contain only field of primitive data types.</typeparam>
 <param name="name">HDF5 path to operate on.</param>
 <param name="record">Record containing the attribute values.</param>    
 <remarks>
 <p>The record must consists only of fields of primitive data types (int, float, string, etc.).</p>
 <p>Each record field is stored as an HDF5 attribute using the same name.</p>
 </remarks>
 <seealso cref="GetRecord``1"/><seealso cref="SetAttribute``1"/>
</member>
<member name="M:Tensor.HDF5.SetAttribute``1(System.String,System.String,``0)">
 <summary>Set attribute value on an HDF5 object.</summary>
 <typeparam name="'T">Type of the attribute value.</typeparam>
 <param name="name">HDF5 path to operate on.</param>
 <param name="atrName">Name of the attribute.</param>
 <param name="value">Value to set attribute to.</param>    
 <seealso cref="GetAttribute``1"/><seealso cref="SetRecord``1"/>    
</member>
<member name="M:Tensor.HDF5.Read``1(System.String)">
 <summary>Read data array from HDF5 file.</summary>
 <typeparam name="'T">Type of the data.</typeparam>
 <param name="name">HDF5 path to read from.</param>
 <returns>A tuple of <c>(data, shape)</c> where <c>data</c> is the read data array and <c>shape</c> is the 
 corresponding shape.</returns>
 <remarks>The type <c>'T</c> must match the data type stored in the HDF5 file, otherwise an exception is raised.
 </remarks>
 <seealso cref="Write``1"/><seealso cref="GetDataType"/><seealso cref="HostTensor.read``1"/>
</member>
<member name="M:Tensor.HDF5.OpenWrite(System.String)">
 <summary>Opens the specified HDF5 file for writing.</summary>
 <param name="path">The path to the HDF5 file.</param>
 <returns>An HDF5 object representing the opened file.</returns>
 <remarks>If the file already exists, it will be overwritten.</remarks>
</member>
<member name="M:Tensor.HDF5.OpenRead(System.String)">
 <summary>Opens the specified HDF5 file for reading.</summary>
 <param name="path">The path to the HDF5 file.</param>
 <returns>An HDF5 object representing the opened file.</returns>
</member>
<member name="M:Tensor.HDF5.GetRecord``1(System.String)">
 <summary>Get attribute values on an HDF5 object and returns them as a record.</summary>
 <typeparam name="'R">Type of the F# record. It must contain only field of primitive data types.</typeparam>
 <param name="name">HDF5 path to operate on.</param>
 <returns>Record containing the attribute values.</returns>    
 <remarks>
 <p>The record must consists only of fields of primitive data types (int, float, string, etc.).</p>
 <p>Each record field is read from an HDF5 attribute using the same name.</p>
 </remarks>
 <seealso cref="SetRecord``1"/><seealso cref="GetAttribute``1"/>
</member>
<member name="M:Tensor.HDF5.GetDataType(System.String)">
 <summary>Get data type of array in HDF5 file.</summary>
 <param name="name">HDF5 path to read from.</param>
 <returns>Data type.</returns>    
</member>
<member name="M:Tensor.HDF5.GetAttribute``1(System.String,System.String)">
 <summary>Get attribute value on an HDF5 object.</summary>
 <typeparam name="'T">Type of the attribute value.</typeparam>
 <param name="name">HDF5 path to operate on.</param>
 <param name="atrName">Name of the attribute.</param>
 <returns>Value of the attribute.</returns>    
 <seealso cref="SetAttribute``1"/><seealso cref="GetRecord``1"/>
</member>
<member name="M:Tensor.HDF5.Finalize">
 <summary>Closes the HDF5 file.</summary>
</member>
<member name="M:Tensor.HDF5.Exists(System.String)">
 <summary>Checks whether an object (array or group) with the given name exists.</summary>
 <param name="name">HDF5 path to check.</param>
 <returns><c>true</c> if the path exists; <c>false</c> otherwise.</returns>
</member>
<member name="M:Tensor.HDF5.System-IDisposable-Dispose">
 <summary>Closes the HDF5 file.</summary>
</member>
<member name="M:Tensor.HDF5.Dispose">
 <summary>Closes the HDF5 file.</summary>
</member>
<member name="M:Tensor.HDF5.CreateParentGroups(System.String)">
<summary>
 Create all necessary parent groups for the given path.
</summary>
</member>
<member name="M:Tensor.HDF5.CreateGroups(System.String)">
 <summary>Creates the given group path.</summary>
 <param name="path">HDF5 group path to create.</param>
 <remarks>All necessary parent groups are created automatically.
 If the group with the given path already exists, nothing happens.</remarks>
</member>
<member name="M:Tensor.HDF5.CombinePath(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Combines a list of groups into a HDF5 path string.
</summary>
</member>
<member name="T:Tensor.HDF5">
 <summary>An object representing an HDF5 file.</summary>
 <remarks>
 <p>HDF5 is an open, cross-plattform, industry-standard file format for data exchange. 
 More information is available at <see href="https://www.hdfgroup.org"/>.</p>
 <p>This object represents an HDF5 file. Use <see cref="OpenRead"/> and <see cref="OpenWrite"/> to open an HDF5 file 
 for reading or writing.</p>
 <p>This object does not aim to expose all functions provided by the HDF5 standard. Instead, it focuses on providing
 a simple interface for reading and writing arrays as well as attributes.</p>
 </remarks>
</member>
<member name="T:Tensor.HDF5Mode.HDF5Overwrite">
<summary>
 (over-)write HDF5 file
</summary>
</member>
<member name="T:Tensor.HDF5Mode.HDF5Read">
<summary>
 read HDF5 file
</summary>
</member>
<member name="T:Tensor.MatrixPart.Lower">
<summary>
 Lower triangular part of the matrix.
</summary>
</member>
<member name="T:Tensor.MatrixPart.Upper">
<summary>
 Upper triangular part of the matrix.
</summary>
</member>
<member name="T:Tensor.MatrixPart">
<summary>
 Upper or lower trianguler part of a matrix.
</summary>
</member>
<member name="T:Tensor.TensorOrder.CustomOrder">
<summary>
 The specified custom memory ordering of dimensions.
</summary>
</member>
<member name="T:Tensor.TensorOrder.ColumnMajor">
<summary>
 Column-major (Fortran) memory order.
</summary>
</member>
<member name="T:Tensor.TensorOrder.RowMajor">
<summary>
 Row-major (C) memory order.
</summary>
</member>
<member name="T:Tensor.TensorOrder">
<summary>
 Memory ordering of a tensor.
</summary>
</member>
<member name="T:Tensor.Rng.AllFill">
<summary>
 Take all elements of remaining dimensions.
</summary>
</member>
<member name="T:Tensor.Rng.NewAxis">
<summary>
 Insert broadcastable axis of size 1.
</summary>
</member>
<member name="T:Tensor.Rng.Rng">
<summary>
 Range of elements, including first and last.
</summary>
</member>
<member name="T:Tensor.Rng.Elem">
<summary>
 The single element specified.
</summary>
</member>
<member name="M:Tensor.Rng.ofItemOrSliceArgs(System.Object[])">
<summary>
 Converts arguments to a .NET Item property or GetSlice, SetSlice method to a TensorRng list.
</summary>
</member>
<member name="P:Tensor.Rng.Pretty">
<summary>
 Pretty string.
</summary>
</member>
<member name="P:Tensor.Rng.All">
<summary>
 All elements.
</summary>
</member>
<member name="T:Tensor.Rng">
<summary>
 Range over a dimension of a tensor.
</summary>
</member>
<member name="P:Tensor.ITensor.M(Microsoft.FSharp.Collections.FSharpList{Tensor.ITensor},Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.M(Tensor.ITensor,Tensor.ITensor,Tensor.ITensor,Tensor.ITensor,Tensor.ITensor,Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.M(Tensor.ITensor,Tensor.ITensor,Tensor.ITensor,Tensor.ITensor,Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.M(Tensor.ITensor,Tensor.ITensor,Tensor.ITensor,Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.M(Tensor.ITensor,Tensor.ITensor,Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.M(Tensor.ITensor,Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.Item(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng},Tensor.ITensor)">
<summary>
 n-dimensional slicing using a list of Rngs
</summary>
</member>
<member name="P:Tensor.ITensor.Storage">
<summary>
 storage of this tensor
</summary>
</member>
<member name="P:Tensor.ITensor.Shape">
<summary>
 shape
</summary>
</member>
<member name="P:Tensor.ITensor.Pretty">
<summary>
 pretty contents string
</summary>
</member>
<member name="P:Tensor.ITensor.NElems">
<summary>
 number of elements
</summary>
</member>
<member name="P:Tensor.ITensor.NDims">
<summary>
 number of dimensions
</summary>
</member>
<member name="P:Tensor.ITensor.M(Microsoft.FSharp.Collections.FSharpList{Tensor.ITensor})">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.M(Tensor.ITensor,Tensor.ITensor,Tensor.ITensor,Tensor.ITensor,Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.M(Tensor.ITensor,Tensor.ITensor,Tensor.ITensor,Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.M(Tensor.ITensor,Tensor.ITensor,Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.M(Tensor.ITensor,Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.M(Tensor.ITensor)">
<summary>
 Element selection using boolean mask. Specify NoMask for a dimension if no masking is desired.   
</summary>
</member>
<member name="P:Tensor.ITensor.Layout">
<summary>
 layout of this tensor (shape, offset and strides)
</summary>
</member>
<member name="P:Tensor.ITensor.Item(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng})">
<summary>
 n-dimensional slicing using a list of Rngs
</summary>
</member>
<member name="P:Tensor.ITensor.Full">
<summary>
 full contents string
</summary>
</member>
<member name="P:Tensor.ITensor.Dev">
<summary>
 storage factory
</summary>
</member>
<member name="P:Tensor.ITensor.DataType">
<summary>
 type of data stored in this tensor
</summary>
</member>
<member name="M:Tensor.ITensor.Transfer(Tensor.Backend.ITensorDevice)">
<summary>
 Transfers this tensor to the specifed device.
</summary>
</member>
<member name="M:Tensor.ITensor.Relayout(Tensor.Backend.TensorLayout)">
<summary>
 a tensor with the same storage but new layout
</summary>
</member>
<member name="M:Tensor.ITensor.FillZero">
<summary>
 fills the tensors with zeros
</summary>
</member>
<member name="M:Tensor.ITensor.Copy(Microsoft.FSharp.Core.FSharpOption{Tensor.TensorOrder})">
<summary>
 returns a copy of the tensor
</summary>
</member>
<member name="T:Tensor.ITensor">
 <summary>Type-neutral interface to Tensor&lt;'T&gt; of any type 'T.</summary>
 <remarks>These functions are useful for working with tensors of unknown types.
 For most use cases the functions provided by <see cref="Tensor`1"/> are better suited.</remarks>
 <seealso cref="Tensor`1"/>
</member>
<member name="M:Tensor.Tensor.PrepareElemwiseSources``4(Tensor.Tensor{``0},Tensor.Tensor{``1},Tensor.Tensor{``2},Tensor.Tensor{``3})">
<summary>
 prepares the sources of an elementwise operation by broadcasting them to the target shape
</summary>
</member>
<member name="M:Tensor.Tensor.PrepareElemwiseSources``3(Tensor.Tensor{``0},Tensor.Tensor{``1},Tensor.Tensor{``2})">
<summary>
 prepares the sources of an elementwise operation by broadcasting them to the target shape
</summary>
</member>
<member name="M:Tensor.Tensor.PrepareElemwiseSources``2(Tensor.Tensor{``0},Tensor.Tensor{``1})">
<summary>
 prepares the sources of an elementwise operation by broadcasting them to the target shape
</summary>
</member>
<member name="M:Tensor.Tensor.PrepareElemwise``4(Tensor.Tensor{``1},Tensor.Tensor{``2},Tensor.Tensor{``3},Microsoft.FSharp.Core.FSharpOption{Tensor.TensorOrder})">
<summary>
 prepares an elementwise operation by broadcasting all three tensors to the same size
 and allocating a target of same size and storage
</summary>
</member>
<member name="M:Tensor.Tensor.PrepareElemwise``3(Tensor.Tensor{``1},Tensor.Tensor{``2},Microsoft.FSharp.Core.FSharpOption{Tensor.TensorOrder})">
<summary>
 prepares an elementwise operation by broadcasting both tensors to the same size
 and allocating a target of same size and storage
</summary>
</member>
<member name="M:Tensor.Tensor.PrepareElemwise``2(Tensor.Tensor{``1},Microsoft.FSharp.Core.FSharpOption{Tensor.TensorOrder})">
<summary>
 prepares an elementwise operation by allocating a target of same size and storage
</summary>
</member>
<member name="M:Tensor.Tensor.PrepareAxisReduceTarget``2(System.Int32,Tensor.Tensor{``1},Microsoft.FSharp.Core.FSharpOption{Tensor.TensorOrder})">
<summary>
 prepares an axis reduce operation by allocating a target of appropriate size and storage
</summary>
</member>
<member name="M:Tensor.Tensor.PrepareAxisReduceSources``2(Tensor.Tensor{``0},System.Int32,Tensor.Tensor{``1},Microsoft.FSharp.Core.FSharpOption{Tensor.Tensor{``0}})">
<summary>
 Prepares the sources of an axis reduce operation (e.g. sum over axis),
 by moving the reduction axis to be the last axis in the source.
</summary>
</member>
<member name="M:Tensor.Tensor.CheckSameStorage(Microsoft.FSharp.Collections.FSharpList{Tensor.ITensor})">
<summary>
 checks that all tensors have the same storage
</summary>
</member>
<member name="M:Tensor.Tensor.CheckSameShape(Tensor.ITensor,Tensor.ITensor)">
<summary>
 checks that two tensors have the same shape
</summary>
</member>
<member name="T:Tensor.Tensor">
<summary>
 See Tensor&lt;&apos;T&gt;.
</summary>
</member>
<member name="F:Tensor.Tensor`1.Storage@">
 <summary>The storage object that holds the data of this tensor.</summary>
 <value>Storage object.</value>
 <remarks>
 <para>The storage object holds the actual data of the tensor.
 A storage object can be associated with one or more tensors, i.e. it can be shared between multiple tensors.
 Sharing occurs, for example, when a view into an existing tensor is created or the tensor is reshapred.</para>
 <para>The actual type of the storage object depends on the device the data of the tensor is stored on.</para>
 <para>For tensors stored in host memory the storage object type is <see cref="Tensor.Host.TensorHostStorage`1"/>.</para>
 <para>For tensors stored on a CUDA GPU the storage object type is <see cref="Tensor.Cuda.TensorCudaStorage`1"/>.</para>
 </remarks>
 <seealso cref="Dev"/><seealso cref="Layout"/>
</member>
<member name="F:Tensor.Tensor`1.Layout@">
 <summary>Memory layout of this tensor.</summary>
 <value>Memory layout.</value>
 <remarks>Provides information of how the data is stored within this tensor.</remarks>
 <seealso cref="Storage"/><seealso cref="Shape"/>
</member>
<member name="M:Tensor.Tensor`1.zerosLike(Tensor.Tensor{`0})">
 <summary>Creates a new tensor filled with zeros using the specified tensor as template.</summary>
 <param name="tmpl">The template tensor.</param>
 <returns>The new tensor.</returns>
 <remarks>
 <para>A new tensor is created with the same shape and on the same device as <paramref name="tmpl"/>.</para>
 <para>The tensor is filled with zeros.</para>
 </remarks>
 <seealso cref="zeros"/>
</member>
<member name="M:Tensor.Tensor`1.zeros(Tensor.Backend.ITensorDevice,Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new tensor filled with zeros (0).</summary>
 <param name="dev">The device to create the tensor on.</param>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <example><code language="fsharp">
 let a = Tensor&lt;float&gt;.zeros HostTensor.Dev [2L; 3L]
 // a = [[0.0; 0.0; 0.0]
 //      [0.0; 0.0; 0.0]]
 </code></example>    
 <remarks>
 <para>A new tensor of the specified shape is created on the specified device.</para>
 <para>The tensor is filled with zeros.</para>
 </remarks>
 <seealso cref="zerosLike"/><seealso cref="ones"/>
</member>
<member name="M:Tensor.Tensor`1.varAxis(System.Int32,Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{System.Int64})">
 <summary>Calculates the variance of the elements along the specified axis.</summary>
 <param name="ax">The axis to operate along.</param>
 <param name="a">The tensor containing the source values.</param>    
 <param name="ddof">The delta degrees of freedom. (default: 0L)</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.varAxis (1, a, ddof=1L) 
 </code></example>
 <remarks>
 <para>The variance is calculated along the specified axis.</para>
 <para>The parameter <paramref name="ddof"/> specifies the difference between the number of elements and the
 degrees of freedom for the computation of the variance. Use <c>ddof=1</c> to obtain an unbiased estimate and
 <c>ddof=0</c> for a maximum-likelihood estimate.</para>
 </remarks>
 <seealso cref="var"/><seealso cref="meanAxis"/><seealso cref="stdAxis"/>
</member>
<member name="M:Tensor.Tensor`1.var(Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{System.Int64})">
 <summary>Calculates the variance of the tensor.</summary>
 <param name="a">The tensor containing the source values.</param>    
 <returns>The variance estimate.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.var a 
 </code></example>
 <remarks>
 <para>The variance is calculated over all elements of the tensor.</para>
 <para>The parameter <paramref name="ddof"/> specifies the difference between the number of elements and the
 degrees of freedom for the computation of the variance. Use <c>ddof=1</c> to obtain an unbiased estimate and
 <c>ddof=0</c> for a maximum-likelihood estimate.</para>
 </remarks>
 <seealso cref="varAxis"/><seealso cref="mean"/><seealso cref="std"/>
</member>
<member name="M:Tensor.Tensor`1.value(Tensor.Tensor{`0})">
 <summary>Gets the value of a zero-dimensional (scalar) tensor.</summary>
 <param name="a">The zero-dimensional tensor to read from.</param>    
 <returns>The scalar value of the tensor.</returns>
 <seealso cref="Value"/>
</member>
<member name="M:Tensor.Tensor`1.tryReshapeView(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Tensor{`0})">
 <summary>Tries to create a reshaped view of the tensor (without copying).</summary>
 <param name="shp">The target shape.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The reshaped tensor, if reshaping without copying is possible. Otherwise <c>None</c>.</returns>
 <remarks>
 <para>Changes the shape of the tensor to the specified shape.
 The total number of elements must not change.
 One dimension of the <paramref name="shp"/> can be specified as <see cref="Tensor.Remainder"/>, 
 in which case the size of that dimension is inferred automatically.</para>
 <para>If a reshape is not possible without copying the data of the tensor, <c>None</c> is returned.</para>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <seealso cref="reshapeView"/><seealso cref="reshape"/>
</member>
<member name="M:Tensor.Tensor`1.tryFind(`0,Tensor.Tensor{`0})">
 <summary>Finds the first occurence of the specfied value and returns its indices.</summary>
 <param name="value">The value to find.</param>
 <param name="a">The tensor containing the source values.</param>    
 <returns>The indices if the value was found, otherwise <c>None</c>.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 3.0]]
 let b = Tensor.tryFind 3.0 a // b = Some [0L; 2L]
 </code></example>
 <remarks>The values is searched for an the index of the first occurence is returned.
 If the value is not found <c>None</c> is returned instead.</remarks>
 <seealso cref="find"/><seealso cref="findAxis"/>
</member>
<member name="M:Tensor.Tensor`1.trues(Tensor.Backend.ITensorDevice,Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new boolean tensor filled with trues.</summary>
 <param name="dev">The device to create the tensor on.</param>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <example><code language="fsharp">
 let a = Tensor.trues HostTensor.Dev [2L; 3L]
 // a = [[true; true; true]
 //      [true; true; true]]
 </code></example>       
 <remarks>
 <para>A new tensor of the specified shape is created on the specified device.</para>
 <para>The tensor is filled with trues.</para>
 </remarks>
 <seealso cref="falses"/>
</member>
<member name="M:Tensor.Tensor`1.trueIdx(Tensor.Tensor{System.Boolean})">
 <summary>Finds the indices of all element that are true.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A matrix that has one row per true entry in <paramref name="src"/>.
 The columns correspond to the dimensions of <paramref name="src"/>.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[true; false; true; false]
                              [false; true; true; false]]
 let b = Tensor.trueIdx a // b = [[0L; 0L]
                          //      [0L; 2L]
                          //      [1L; 1L]
                          //      [1L; 2L]]
 </code></example>
 <remarks>The function searches for elements that are true and for each one it creates a row
 in the result matrix consisting of the indices of the element.</remarks>
</member>
<member name="M:Tensor.Tensor`1.transpose(Tensor.Tensor{`0})">
 <summary>(Batched) transpose of a matrix.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>The result of this operation.</returns>
 <seealso cref="T"/>
</member>
<member name="M:Tensor.Tensor`1.transfer(Tensor.Backend.ITensorDevice,Tensor.Tensor{`0})">
 <summary>Transfers a tensor to the specifed device.</summary>
 <param name="dev">The target device.</param>
 <param name="a">The tensor to transfer.</param>
 <returns>A tensor on the target device.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [3L; 5L] // a.Dev = HostTensor.Dev
 let b = Tensor.transfer CudaTensor.Dev a // b.Dev = CudaTensor.Dev
 </code></example>       
 <remarks>    
 <para>A new tensor is created on the specified device.</para>
 <para>The elements of the original tensor are copied into the new tensor.</para>
 <para>If the target device matches the current device of the tensor, the original tensor is returned.</para>
 </remarks>    
 <seealso cref="TransferFrom"/><seealso cref="Dev"/><seealso cref="copy"/>
</member>
<member name="M:Tensor.Tensor`1.traceAxis(System.Int32,System.Int32,Tensor.Tensor{`0})">
 <summary>Calculates the trace along the specified axes.</summary>
 <param name="ax1">The first axis of the diagonal to compute the trace along.</param>
 <param name="ax2">The second axis of the diagonal to compute the trace along.</param>
 <param name="a">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [2L; 3L; 4L; 3L]
 let b = Tensor.traceAxis 1 3 a // b.Shape = [2L; 4L]
 </code></example>
 <remarks>
 <para>The trace is calculated along the specified axes. It is defined by the sum of the elements on the
 diagonal.</para>
 <para>The tensor must have the same size in dimensions <paramref name="ax1"/> and <paramref name="ax2"/>.</para>
 </remarks>
 <seealso cref="trace"/>
</member>
<member name="M:Tensor.Tensor`1.trace(Tensor.Tensor{`0})">
 <summary>Calculates the trace of the matrix.</summary>
 <param name="a">A square matrix.</param>    
 <returns>The trace of the matrix.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [3L; 3L]
 let b = Tensor.trace a 
 </code></example>    
 <remarks>    
 <para>The trace is is defined by the sum of the elements on the diagonal.</para>
 <para>The matrix must be square.</para>
 <para>If the specified tensor has more than two dimensions, the traces along the last two dimensions 
 are returned as a tensor.</para>
 </remarks>    
 <seealso cref="traceAxis"/><seealso cref="diag"/>
</member>
<member name="M:Tensor.Tensor`1.tensorProduct(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Computes the tensor product between two tensors.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>    
</member>
<member name="M:Tensor.Tensor`1.symmetricEigenDecomposition(Tensor.MatrixPart,Tensor.Tensor{`0})">
 <summary>Computes the (real) eigendecomposition of a symmetric matrix.</summary>
 <param name="part">Specifies which part of the matrix should be used.</param>
 <param name="a">The input matrix to this operation.</param>
 <returns>A tuple consisting of <c>(vals, vecs)</c> where each column of <c>vecs</c> is the eigenvector for the
 corresponding eigenvalue in <c>vals</c>.</returns>
 <remarks>
 <para>The eigendecomposition of a symmetric matrix is real.
 Only the part of the matrix specified by <paramref name="part"/> is used. The other part is ignored and can
 contain arbitrary values.</para>
 </remarks>
 <seealso cref="FillSymmetricEigenDecomposition"/>
</member>
<member name="M:Tensor.Tensor`1.swapDim(System.Int32,System.Int32,Tensor.Tensor{`0})">
 <summary>Swaps the specified dimensions of the tensor.</summary>
 <param name="ax1">The dimension to swap.</param>
 <param name="ax2">The dimension to swap with.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The tensor with the dimensions swapped.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [2L; 3L; 4L]
 let b = Tensor.swapDim 0 2 a // b.Shape = [4L; 3L; 2L]
 </code></example>    
 <remarks>    
 <para>A view of the original tensor is returned and the storage is shared. Modifications done to the returned 
 tensor will affect the original tensor.</para>
 </remarks>    
 <seealso cref="permuteAxes"/><seealso cref="T"/>
</member>
<member name="M:Tensor.Tensor`1.sumTensor(Tensor.Tensor{`0})">
 <summary>Sums all elements returning a Tensor.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new scalar tensor containing the result of this operation.</returns>
 <seealso cref="sum"/>
</member>
<member name="M:Tensor.Tensor`1.sumAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Sums the elements along the specified axis.</summary>
 <param name="ax">The axis to sum along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.sumAxis 1 a // b = [10.0; 26.0]
 </code></example>
 <remarks>Elements are summed along the specified axis. An empty sum equals zero.</remarks>
 <seealso cref="FillSumAxis"/><seealso cref="sum"/>
</member>
<member name="M:Tensor.Tensor`1.sum(Tensor.Tensor{`0})">
 <summary>Sums all elements.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A scalar containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.sum a // b = 36.0
 </code></example>
 <remarks>All elements are summed. An empty sum equals zero.</remarks>
 <seealso cref="sumAxis"/><seealso cref="sumTensor"/>
</member>
<member name="M:Tensor.Tensor`1.stdAxis(System.Int32,Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{System.Int64})">
 <summary>Calculates the standard deviation of the elements along the specified axis.</summary>
 <param name="ax">The axis to operate along.</param>
 <param name="a">The tensor containing the source values.</param>    
 <param name="ddof">The delta degrees of freedom. (default: 0L)</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.stdAxis (1, a, ddof=1L) 
 </code></example>
 <remarks>
 <para>The standard deviation is calculated along the specified axis.</para>
 <para>The parameter <paramref name="ddof"/> specifies the difference between the number of elements and the
 degrees of freedom for the computation of the variance. Use <c>ddof=1</c> to obtain an unbiased estimate and
 <c>ddof=0</c> for a maximum-likelihood estimate.</para>
 </remarks>
 <seealso cref="std"/><seealso cref="meanAxis"/><seealso cref="varAxis"/>
</member>
<member name="M:Tensor.Tensor`1.std(Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{System.Int64})">
 <summary>Calculates the standard deviation of the tensor.</summary>
 <param name="a">The tensor containing the source values.</param>    
 <param name="ddof">The delta degrees of freedom. (default: 0L)</param>
 <returns>The standard deviation estimate.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.std a 
 </code></example>
 <remarks>
 <para>The standard deviation is calculated over all elements of the tensor.</para>
 <para>The parameter <paramref name="ddof"/> specifies the difference between the number of elements and the
 degrees of freedom for the computation of the variance. Use <c>ddof=1</c> to obtain an unbiased estimate and
 <c>ddof=0</c> for a maximum-likelihood estimate.</para>
 </remarks>
 <seealso cref="stdAxis"/><seealso cref="mean"/><seealso cref="var"/>
</member>
<member name="M:Tensor.Tensor`1.shape(Tensor.Tensor{`0})">
 <summary>Shape of the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Shape.</returns>
 <seealso cref="Shape"/>
</member>
<member name="P:Tensor.Tensor`1.Value(`0)">
 <summary>Accesses the value of a zero-dimensional (scalar) tensor.</summary>
 <value>The scalar value of the tensor.</value>
 <example><code language="fsharp">
 let a = HostTensor.sclar 2.0
 let b = a.Value // 2.0
 a.Value &lt;- 3.0 // a = 3.0
 </code></example>
 <remarks>
 <para>Gets or sets the value of a scalar tensor.</para>
 <para>The tensor must have zero dimensions.</para>
 </remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the tensor is not zero-dimensional.</exception>
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{System.Int64})"/>
</member>
<member name="P:Tensor.Tensor`1.M(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{System.Boolean}},Tensor.Tensor{`0})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="masks">A list of boolean mask tensors or <see cref="Tensor.NoMask"/>.</param>
 <value>All elements from the tensor for which the mask is true.</value>
 <remarks>
 <para>Masking picks elements from the tensor for which the corresponding element in the mask tensor is true.
 The mask can, for example, be generated by one or more element-wise comparison operation.</para>
 <para>The get operation returns a copy of the selected elements of the tensor.</para>
 <para>The set operation replaces the selected elements with a copy of the specified tensor.</para>
 <para>If a dimension should not be masked, specify <see cref="Tensor.NoMask"/> instead of a mask tensor.</para>
 <para>This mask specification variant is intended for programmatically generated ranges. For most use cases
 the variant <seealso cref="M(Tensor.Tensor{System.Boolean})"/> is more succinct and thus the 
 recommended method.</para>    
 </remarks>
 <exception cref="System.InvalidArgumentException">Raised when the mask is incompatible with the tensor.</exception>
 <seealso cref="M(Tensor.Tensor{System.Boolean})"/>
</member>
<member name="P:Tensor.Tensor`1.M(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{`0})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="m0">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m1">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m2">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m3">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>    
 <param name="m4">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>    
</member>
<member name="P:Tensor.Tensor`1.M(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{`0})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="m0">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m1">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m2">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m3">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>    
</member>
<member name="P:Tensor.Tensor`1.M(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{`0})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="m0">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m1">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m2">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>    
</member>
<member name="P:Tensor.Tensor`1.M(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{`0})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="m0">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m1">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
</member>
<member name="P:Tensor.Tensor`1.M(Tensor.Tensor{System.Boolean},Tensor.Tensor{`0})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="m0">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <value>All elements from the tensor for which the mask is true.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0; 3.0]
                            [4.0; 5.0; 6.0]]

 // masked get with one mask for the whole tensor
 let m = HostTensor.ofList [[true;  true;  false]
                            [false; false; true ]]
 let b = a.M(m) // b = [1.0; 2.0; 6.0]

 // an element-wise comparison operator can be used to create the mask
 let c = a.M(a >>>> 3.5) // c = [4.0; 5.0; 6.0]

 // masked get with one mask per dimension
 let m0 = HostTensor.ofList [true; false]
 let m1 = HostTensor.ofList [false; false; true]
 let d = a.M(m0, m1) // d = [3.0]

 // masked get using only one dimension
 let m0 = HostTensor.ofList [true; false]
 let e = a.M(m0, NoMask) // e = [[1.0; 2.0; 3.0]]

 // masked set with one mask for the whole tensor
 let m = HostTensor.ofList [[true;  true;  false]
                            [false; false; true ]]
 a.M(m) &lt;- [8.0; 9.0; 0.0]  // a = [[8.0; 9.0; 3.0]
                            //      [4.0; 5.0; 0.0]]
 </code></example>    
 <remarks>
 <para>Masking picks elements from the tensor for which the corresponding element in the mask tensor is true.
 The mask can, for example, be generated by one or more element-wise comparison operation.</para>
 <para>The get operation returns a copy of the selected elements of the tensor.</para>
 <para>The set operation replaces the selected elements with a copy of the specified tensor.</para>
 <para>If a dimension should not be masked, specify <see cref="Tensor.NoMask"/> instead of a mask tensor.</para>
 <para>For clarity the documentation does not list all overloads of <c>M</c>.
 However, this masking method can be used for up to 5 dimensions, as shown in the example.
 For programmatically generated ranges or for more than 5 dimensions, the mask specification variant 
 <see cref="M(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{System.Boolean}})"/> is available.</para>
 <para>Currently this operation is only supported for tensors stored on the host. Support for CUDA tensors is
 planned in the future.</para>
 </remarks>
 <exception cref="System.InvalidArgumentException">Raised when the mask is incompatible with the tensor.</exception>
 <seealso cref="M(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{System.Boolean}})"/>
</member>
<member name="P:Tensor.Tensor`1.Item(System.Int64,Tensor.Tensor{`0})">
 <summary>Accesses a slice (part) of the tensor.</summary>
 <param name="i0">The range of the tensor to select.</param>
 <value>A view of the selected part of the tensor.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0; 3.0]
                            [4.0; 5.0; 6.0]]

 // get view
 let b = a.[0L, 1L] // b = 2.0
 let c = a.[0L, *] // b = [1.0; 2.0; 3.0]
 let d = a.[1L, 0L..1L] // b = [4.0; 5.0]
 let e = a.[1L..1L, 0L..1L] // b = [[4.0; 5.0]]

 // set view
 a.[0L, *] &lt;- HostTensor.ofList [7.0; 8.0; 9.0] // a = [[7.0; 8.0; 9.0]
                                                //      [4.0; 5.0; 6.0]]

 // modifiying view affects original tensor
 d.[[1L]] &lt;- 0.0 // a = [[7.0; 8.0; 9.0]
                 //      [4.0; 0.0; 6.0]]
 </code></example>    
 <remarks>
 <para>Indexing is zero-based.</para>
 <para>This indexing options allows to select a part (called slice) of the tensor.</para>
 <para>The get operation returns a view of the specified part of the tensor. Modifications done to that
 view will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 <para>The slicing specifications follows standard F# practice. 
 Specifying an integer for the index of a dimension, selects that index for the dimension.
 Specifying <c>*</c> for a dimension, selects all indices of the dimension.
 Specifying <c>f..l</c> for a dimension, select all indices from <c>f</c> to (including) <c>l</c> for the dimension.
 </para>
 <para>For clarity the documentation does not list all overloads of the Item property and GetSlice, 
 SetSlice methods. However, this slicing method can be used for up to 5 dimensions, as shown in the example.
 For programmatically generated ranges or for more than 5 dimensions, the range specification variant 
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng})"/> is available.</para>
 </remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the specified range is out of range.</exception>
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng})"/>
</member>
<member name="P:Tensor.Tensor`1.Item(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng},Tensor.Tensor{`0})">
 <summary>Accesses a slice (part) of the tensor.</summary>
 <param name="rng">The range of the tensor to select.</param>
 <value>A view of the selected part of the tensor.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0; 3.0]
                            [4.0; 5.0; 6.0]]

 // get view
 let b = a.[[Rng.Elem 0L; Rng.Elem 1L]] // b = 2.0
 let c = a.[[Rng.Elem 0L; Rng.All]] // b = [1.0; 2.0; 3.0]
 let d = a.[[Rng.Elem 1L; Rng.Rng (Some 0L, Some 1L)]] // b = [4.0; 5.0]
 let e = a.[[Rng.Rng (Some 1L, Some 1L); Rng (Some 0L, Some 1L)]] // b = [[4.0; 5.0]]

 // set view
 a.[[Rng.Elem 0L; Rng.All]] &lt;- HostTensor.ofList [7.0; 8.0; 9.0] // a = [[7.0; 8.0; 9.0]
                                                                 //      [4.0; 5.0; 6.0]]

 // modifiying view affects original tensor
 d.[[1L]] &lt;- 0.0 // a = [[7.0; 8.0; 9.0]
                 //      [4.0; 0.0; 6.0]]
 </code></example>    
 <remarks>
 <para>This range specification variant is intended for programmatically generated ranges. For most use cases
 the variant <seealso cref="Item(System.Int64)"/> allows vastly simpler range specifications and is the 
 recommended method.</para>
 <para>Indexing is zero-based.</para>
 <para>This indexing options allows to select a part (called slice) of the tensor.</para>
 <para>The get operation returns a view of the specified part of the tensor. Modifications done to that
 view will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 <para>See <see cref="Tensor.Rng"/> for available range specifications.</para>
 </remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the specified range is out of range.</exception>
 <seealso cref="Item(System.Int64)"/>
</member>
<member name="P:Tensor.Tensor`1.Item(Microsoft.FSharp.Collections.FSharpList{System.Int64},`0)">
 <summary>Accesses a single element within the tensor.</summary>
 <param name="idx">A list consisting of the indicies of the element to access. The list must have one entry
 per dimension of this tensor.</param>
 <value>The value of the selected element.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0]
                            [3.0; 4.0]]
 let b = a.[[1L; 1L]] // b = 4.0
 a.[[1L; 0L]] &lt;- 6.0 // a = [[1.0; 2.0]
                     //      [6.0; 4.0]]                        
 </code></example>    
 <remarks>
 <para>Indexing is zero-based.</para>
 <para>Use <see cref="Item(System.Int64[])"/> for faster element access.</para>
 </remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the specified indicies are out of range.</exception>
 <seealso cref="Item(System.Int64[])"/><seealso cref="Value"/>
</member>
<member name="P:Tensor.Tensor`1.Item(System.Int64[],`0)">
 <summary>Accesses a single element within the tensor.</summary>
 <param name="idx">An array consisting of the indicies of the element to access. The arry must have one entry
 per dimension of this tensor.</param>
 <value>The value of the selected element.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0]
                            [3.0; 4.0]]
 let b = a.[[|1L; 1L|]] // b = 4.0
 a.[[|1L; 0L|]] &lt;- 6.0 // a = [[1.0; 2.0]
                       //      [6.0; 4.0]]                        
 </code></example>    
 <remarks>
 <para>Indexing is zero-based.</para>
 </remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the specified indicies are out of range.</exception>
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{System.Int64})"/>
</member>
<member name="M:Tensor.Tensor`1.set(Tensor.Tensor{`0},Microsoft.FSharp.Collections.FSharpList{System.Int64},`0)">
 <summary>Sets the value of a single element of the tensor.</summary>
 <param name="a">The tensor to write to.</param>
 <param name="pos">A list consisting of the indicies of the element to access. The list must have one entry
 per dimension of this tensor.</param>
 <param name="value">The new value of the element.</param>
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{System.Int64})"/>
</member>
<member name="M:Tensor.Tensor`1.scatter(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{Tensor.Tensor{System.Int64}}},Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Tensor{`0})">
 <summary>Disperses elements from a source tensor to a new tensor according to the specified indices.</summary>
 <param name="indices">A list of tensors, one per dimension of this tensor, containing the target indicies
 for each element of <paramref name="src"/>.</param>
 <param name="trgtShp">The shape of the resulting tensor.</param>    
 <param name="src">The tensor containing the source values.</param>    
 <returns>Result with the shape specified in <paramref name="trgtShp"/>.</returns>
 <example><code language="fsharp">
 // Sum first row of src into last element and swap rows 1 and 2.
 let src = HostTensor.ofList2D [[0.0; 0.1; 0.2; 0.3]
                                [1.0; 1.1; 1.2; 1.3]
                                [2.0; 2.1; 2.2; 2.3]]
 let i0 = HostTensor.ofList2D [[0L; 0L; 0L; 0L]
                               [2L; 2L; 2L; 2L]
                               [1L; 1L; 1L; 1L]]
 let i1 = HostTensor.ofList2D [[3L; 3L; 3L; 3L]
                               [0L; 1L; 2L; 3L]
                               [0L; 1L; 2L; 3L]]
 let s = Tensor.scatter [Some i0; Some i1] [4L; 4L] src
 // s =
 //     [[   0.0000    0.0000    0.0000    0.6000]
 //      [   2.0000    2.1000    2.2000    2.3000]
 //      [   1.0000    1.1000    1.2000    1.3000]
 //      [   0.0000    0.0000    0.0000    0.0000]]    
 </code></example>
 <remarks>
 <para>The source element with indices <c>[i_0; i_1; i_2; ...]</c> is written to the target element with indices 
 <c>[j_0; j_1; j_2; ...]</c>, where each index <c>j_k</c> is given by <c>j_k = indices.[k].[i_0; i_1; i_2; ...]</c>.
 If <c>indices.[k]</c> is <c>None</c>, then <c>j_k = i_k</c> is assumed instead.</para>
 <para>If a target index occurs multiple times, the corresponding source values are summed.
 If a target element is not referenced by any index, it is set to zero.</para>
 <para>The tensors <paramref name="indices"/> and <paramref name="src"/> must have the same storage.</para>
 </remarks>
 <seealso cref="FillScatter"/><seealso cref="gather"/>
</member>
<member name="M:Tensor.Tensor`1.scalarLike(Tensor.ITensor,`0)">
 <summary>Creates a new zero-dimensional (scalar) tensor using the specified tensor as template and with 
 the specified value.</summary>
 <param name="tmpl">The template tensor.</param>
 <param name="value">The value of the new, scalar tensor.</param>
 <returns>The new tensor.</returns>
 <remarks>
 <para>A new tensor of zero-dimensional shape is created on the same device as <paramref name="tmpl"/>.</para>
 <para>The values of the tensor is set to the specified value.</para>
 </remarks>
 <seealso cref="scalar"/>
</member>
<member name="M:Tensor.Tensor`1.scalar(Tensor.Backend.ITensorDevice,`0)">
 <summary>Creates a new zero-dimensional (scalar) tensor with the specified value.</summary>
 <param name="dev">The device to create the tensor on.</param>
 <param name="value">The value of the new, scalar tensor.</param>
 <returns>The new tensor.</returns>
 <example><code language="fsharp">
 let a = Tensor.scalar HostTensor.Dev 2.5f
 // a = 2.5f
 </code></example>       
 <remarks>
 <para>A new tensor of zero-dimensional shape is created on the specified device.</para>
 <para>The values of the tensor is set to the specified value.</para>
 </remarks>
 <seealso cref="scalarLike"/>
</member>
<member name="M:Tensor.Tensor`1.reverseAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Reverses the elements in the specified dimension.</summary>
 <param name="ax">The axis to reverse.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The tensor with the dimensions permuted.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [0; 1; 2; 3]
 let b = Tensor.reverseAxis 0 a // b = [3; 2; 1; 0]
 </code></example>    
 <remarks>    
 <para>The elements along the specified axis are reversed.</para>
 <para>A view of the original tensor is returned and the storage is shared. Modifications done to the returned 
 tensor will affect the original tensor.</para>
 </remarks>    
</member>
<member name="M:Tensor.Tensor`1.reshapeView(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Tensor{`0})">
 <summary>Creates a reshaped view of the tensor (without copying).</summary>
 <param name="shp">The target shape.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>A reshaped view of the original tensor.</returns>
 <remarks>
 <para>Changes the shape of the tensor to the specified shape.
 The total number of elements must not change.
 One dimension of the <paramref name="shp"/> can be specified as <see cref="Tensor.Remainder"/>, 
 in which case the size of that dimension is inferred automatically.</para>
 <para>If a reshape is not possible without copying the data of the tensor, an exception is raised.
 To avoid this, use <see cref="tryReshapeView"/> instead.</para>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <seealso cref="tryReshapeView"/><seealso cref="reshape"/>
</member>
<member name="M:Tensor.Tensor`1.reshape(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Tensor{`0})">
 <summary>Changes the shape of a tensor.</summary>
 <param name="shp">The target shape.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>A tensor of the specified shape.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [2L; 3L; 4L]
 let b = Tensor.reshape [6L; 4L] a // b.Shape = [6L; 4L]
 let c = Tensor.reshape [2L; Remainder; 1L] a // c.Shape = [2L; 12L; 1L]
 </code></example>    
 <remarks>
 <para>Changes the shape of the tensor to the specified shape.
 The total number of elements must not change.
 One dimension of the <paramref name="shp"/> can be specified as <see cref="Tensor.Remainder"/>, 
 in which case the size of that dimension is inferred automatically.</para>
 <para>If a reshape is possible without copying the data of the tensor, a view of the original tensor is returned
 and the storage is shared. In this case, modifications done to the returned tensor will affect the original 
 tensor.</para>
 <para>If a reshape is not possible without copying the data of the tensor, a new tensor of the specified shape
 and a new storage is allocated and the data is copied into the new tensor.</para>
 </remarks>
 <seealso cref="tryReshapeView"/><seealso cref="reshapeView"/><seealso cref="flatten"/><seealso cref="Shape"/>
</member>
<member name="M:Tensor.Tensor`1.replicate(System.Int32,System.Int64,Tensor.Tensor{`0})">
 <summary>Repeats the tensor along an axis.</summary>
 <param name="ax">The axis to repeat along.</param>        
 <param name="reps">The number of repetitions.</param>
 <param name="a">The tensor to repeat.</param>    
 <returns>The repeated tensor.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [4L; 28L]
 let b = Tensor.replicate 0 10L a // b.Shape = [40L; 28L]
 </code></example>    
 <remarks>    
 <para>The contents of a the tensors are replicated <paramref name="reps"/> times in the specifed dimension.</para>
 </remarks>    
</member>
<member name="M:Tensor.Tensor`1.relayout(Tensor.Backend.TensorLayout,Tensor.Tensor{`0})">
 <summary>Creates a tensor with the specified layout sharing its storage with the original tensor.</summary>
 <param name="newLayout">The new tensor memory layout.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
</member>
<member name="M:Tensor.Tensor`1.range(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng},Tensor.Tensor{`0})">
 <summary>Get a slice (part) of the tensor.</summary>
 <param name="rng">The range of the tensor to select.</param>    
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng})"/>
</member>
<member name="M:Tensor.Tensor`1.pseudoInvert(Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{`0})">
 <summary>Computes the (batched) Moore-Penrose pseudo-inverse of the specified matrix.</summary>
 <param name="a">The input matrix or tensor to this operation.</param>
 <param name="rCond">The cut-off value for the singular values. (default: 1e-15)</param>
 <returns>A new matrix or tensor containing the result of this operation.</returns>
 <remarks>    
 <para>If <paramref name="a"/> is a matrix, its pseudo-inverse is computed. The result is a matrix.</para>
 <para>If <paramref name="a"/> is a tensor of shape <c>[b_1; ...; b_n; i; j]</c>, the pseudo-inverse
 of all matrices consisting of the last two dimensions of the tensor are computed. 
 The result is a tensor of shape <c>[b_1; ...; b_n; j; i]</c>.</para>
 </remarks>
 <seealso cref="FillPseudoInvert"/><seealso cref="invert"/>   
</member>
<member name="M:Tensor.Tensor`1.productTensor(Tensor.Tensor{`0})">
 <summary>Calculates the product all elements returning a Tensor.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new scalar tensor containing the result of this operation.</returns>
 <seealso cref="product"/>
</member>
<member name="M:Tensor.Tensor`1.productAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Calculates the product of the elements along the specified axis.</summary>
 <param name="ax">The axis to calculate the product along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.productAxis 1 a // b = [24.0; 1680.0]
 </code></example>
 <remarks>The product is calculated along the specified axis. An empty product equals one.</remarks>
 <seealso cref="FillProductAxis"/><seealso cref="product"/>
</member>
<member name="M:Tensor.Tensor`1.product(Tensor.Tensor{`0})">
 <summary>Calculates the product of all elements.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A scalar containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.product a // b = 40320.0
 </code></example>
 <remarks>The product of all elements is calculated. An empty product equals one.</remarks>
 <seealso cref="productAxis"/><seealso cref="productTensor"/>
</member>
<member name="M:Tensor.Tensor`1.permuteAxes(Microsoft.FSharp.Collections.FSharpList{System.Int32},Tensor.Tensor{`0})">
 <summary>Permutes the axes as specified.</summary>
 <param name="permut">The permutation to apply to the dimensions of tensor.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The tensor with the dimensions permuted.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [0L; 11L; 22L; 33L; 44L]
 let b = Tensor.permuteAxes [3; 2; 4; 1; 0] a // b.Shape = [44L; 33L; 11L; 0L; 22L]
 </code></example>    
 <remarks>    
 <para>Each entry in the specified permutation specifies the new position of the corresponding axis, i.e. to 
 which position the axis moves.</para>
 <para>A view of the original tensor is returned and the storage is shared. Modifications done to the returned 
 tensor will affect the original tensor.</para>
 </remarks>    
 <seealso cref="swapDim"/><seealso cref="T"/>
</member>
<member name="M:Tensor.Tensor`1.padToSame(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{`0}})">
 <summary>Pads all specified tensors from the left with dimensions of size one until they have the 
 same dimensionality.</summary>
 <param name="xs">A list of tensors to operate on.</param>
 <returns>A list of the resulting tensors, all having the same dimensionality.</returns>
 <seealso cref="padToSame``2"/>
</member>
<member name="M:Tensor.Tensor`1.padToSame``3(Tensor.Tensor{``0},Tensor.Tensor{``1},Tensor.Tensor{``2})">
 <summary>Pads all specified tensors from the left with dimensions of size one until they have the 
 same dimensionality.</summary>
 <param name="a">The tensor to operate on.</param>
 <param name="b">The tensor to operate on.</param>    
 <param name="c">The tensor to operate on.</param>    
 <returns>A tuple of the resulting tensors, all having the same dimensionality.</returns>
 <seealso cref="padToSame``2"/>
</member>
<member name="M:Tensor.Tensor`1.padToSame``2(Tensor.Tensor{``0},Tensor.Tensor{``1})">
 <summary>Pads all specified tensors from the left with dimensions of size one until they have the 
 same dimensionality.</summary>
 <param name="a">The tensor to operate on.</param>
 <param name="b">The tensor to operate on.</param>    
 <returns>A tuple of the resulting tensors, all having the same dimensionality.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [4L; 5L]
 let b = HostTensor.zeros [3L; 4L; 5L]
 let pa, pb = Tensor.padToSame (a, b) // pa.Shape = [1L; 4L; 5L]; pb.Shape = [3L; 4L; 5L]
 </code></example>    
 <remarks>
 <para>Size one dimensions are added from the left to each tensor until all of them have the same 
 dimensionality.</para>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <seealso cref="padLeft"/><seealso cref="broadcastToSame"/>
</member>
<member name="M:Tensor.Tensor`1.padRight(Tensor.Tensor{`0})">
 <summary>Append a dimension of size one after the last dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [3L; 4L; 5L]
 let b = Tensor.padRight a // b.Shape = [3L; 4L; 5L; 1L]
 </code></example>    
 <remarks>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <seealso cref="padLeft"/><seealso cref="insertAxis"/>
</member>
<member name="M:Tensor.Tensor`1.padLeft(Tensor.Tensor{`0})">
 <summary>Insert a dimension of size one as the first dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [3L; 4L; 5L]
 let b = Tensor.padLeft a // b.Shape = [1L; 3L; 4L; 5L]
 </code></example>    
 <remarks>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <seealso cref="padRight"/><seealso cref="insertAxis"/>
</member>
<member name="M:Tensor.Tensor`1.op_UnaryPlus(Tensor.Tensor{`0})">
 <summary>Element-wise prefix plus.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let c = +a  // c = [5.0; 6.0; 7.0]
 </code></example>
 <remarks>
 <para>Applies the unary plus operator to each element of tensor <paramref name="a"/> and returns the result 
 as a new tensor.</para>
 <para>For most data types, this operation does not change the value.</para>
 </remarks>
 <seealso cref="FillUnaryPlus"/>
</member>
<member name="M:Tensor.Tensor`1.op_UnaryNegation(Tensor.Tensor{`0})">
 <summary>Element-wise negation.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let c = -a  // c = [-5.0; -6.0; -7.0]
 </code></example>
 <remarks>
 <para>Negates each element of tensor <paramref name="a"/> and returns the result as a new tensor.</para>
 </remarks>
 <seealso cref="FillNegate"/>
</member>
<member name="M:Tensor.Tensor`1.op_TwiddleTwiddleTwiddleTwiddle(Tensor.Tensor{System.Boolean})">
 <summary>Element-wise logical negation.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [true; false]
 let b = ~~~~a // b = [false; true]
 </code></example>
 <remarks>Logically negates each element of the specified tensor and returns the results as a new tensor.
 </remarks>
 <seealso cref="FillNegate"/>
</member>
<member name="M:Tensor.Tensor`1.op_Subtraction(`0,Tensor.Tensor{`0})">
 <summary>Element-wise substraction with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_Subtraction"/>
</member>
<member name="M:Tensor.Tensor`1.op_Subtraction(Tensor.Tensor{`0},`0)">
 <summary>Element-wise substraction with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_Subtraction"/>
</member>
<member name="M:Tensor.Tensor`1.op_Subtraction(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise substraction.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let b = HostTensor.ofList [2.0; 3.0; 4.0]
 let c = a - b // c = [3.0; 3.0; 3.0]
 </code></example>
 <remarks>
 <para>Substracts each element of tensor <paramref name="b"/> from the corresponding element of tensor <paramref name="a"/>
 and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same type and storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillSubtract"/>
</member>
<member name="M:Tensor.Tensor`1.op_Multiply(`0,Tensor.Tensor{`0})">
 <summary>Element-wise multiplication with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_Multiply"/>
</member>
<member name="M:Tensor.Tensor`1.op_Multiply(Tensor.Tensor{`0},`0)">
 <summary>Element-wise multiplication with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_Multiply"/>
</member>
<member name="M:Tensor.Tensor`1.op_Multiply(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise multiplication.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let b = HostTensor.ofList [2.0; 3.0; 4.0]
 let c = a * b // c = [10.0; 18.0; 28.0]
 </code></example>
 <remarks>
 <para>Multiplies each element of tensor <paramref name="a"/> with the corresponding element of tensor <paramref name="b"/>
 and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same type and storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillMultiply"/>
</member>
<member name="M:Tensor.Tensor`1.op_Modulus(`0,Tensor.Tensor{`0})">
 <summary>Element-wise division with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_Modulus"/>
</member>
<member name="M:Tensor.Tensor`1.op_Modulus(Tensor.Tensor{`0},`0)">
 <summary>Element-wise remainder of division with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_Modulus"/>
</member>
<member name="M:Tensor.Tensor`1.op_Modulus(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise remainder of division.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let b = HostTensor.ofList [2.0; 3.0; 4.0]
 let c = a % b // c = [1.0; 0.0; 3.0]
 </code></example>
 <remarks>
 <para>Computes the remainder of dividing each element of tensor <paramref name="a"/> by the corresponding 
 element of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same type and storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillModulo"/>
</member>
<member name="M:Tensor.Tensor`1.op_LessLessLessLess(`0,Tensor.Tensor{`0})">
 <summary>Element-wise less-than test with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_LessLessLessLess"/>
</member>
<member name="M:Tensor.Tensor`1.op_LessLessLessLess(Tensor.Tensor{`0},`0)">
 <summary>Element-wise less-than test with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_LessLessLessLess"/>
</member>
<member name="M:Tensor.Tensor`1.op_LessLessLessLess(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise less-than test.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [2.0; 4.0; 6.0]
 let b = HostTensor.ofList [1.0; 4.0; 7.0]
 let c = a &lt;&lt;&lt;&lt; b // c = [false; false; true]
 </code></example>
 <remarks>
 <para>Test each element of tensor <paramref name="a"/> for being less than the corresponding element 
 of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage and type.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillLess``1"/>
</member>
<member name="M:Tensor.Tensor`1.op_LessLessGreaterGreater(`0,Tensor.Tensor{`0})">
 <summary>Element-wise not-equality test with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_LessLessGreaterGreater"/>
</member>
<member name="M:Tensor.Tensor`1.op_LessLessGreaterGreater(Tensor.Tensor{`0},`0)">
 <summary>Element-wise not-equality test with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_LessLessGreaterGreater"/>
</member>
<member name="M:Tensor.Tensor`1.op_LessLessGreaterGreater(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise not-equality test.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [2.0; 4.0; 6.0]
 let b = HostTensor.ofList [1.0; 4.0; 7.0]
 let c = a &lt;&lt;>> b // c = [true; false; true]
 </code></example>
 <remarks>
 <para>Test each element of tensor <paramref name="a"/> for being not equal to the corresponding element 
 of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage and type.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillNotEqual``1"/>
</member>
<member name="M:Tensor.Tensor`1.op_LessLessEqualsEquals(`0,Tensor.Tensor{`0})">
 <summary>Element-wise less-than-or-equal test with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_LessLessEqualsEquals"/>
</member>
<member name="M:Tensor.Tensor`1.op_LessLessEqualsEquals(Tensor.Tensor{`0},`0)">
 <summary>Element-wise less-than-or-equal test with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_LessLessEqualsEquals"/>
</member>
<member name="M:Tensor.Tensor`1.op_LessLessEqualsEquals(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise less-than-or-equal test.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [2.0; 4.0; 6.0]
 let b = HostTensor.ofList [1.0; 4.0; 7.0]
 let c = a &lt;&lt;== b // c = [false; true; true]
 </code></example>
 <remarks>
 <para>Test each element of tensor <paramref name="a"/> for being less than or equal to the corresponding element 
 of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage and type.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillLessOrEqual``1"/>
</member>
<member name="M:Tensor.Tensor`1.op_HatHatHatHat(System.Boolean,Tensor.Tensor{System.Boolean})">
 <summary>Element-wise loigcal xor with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_HatHatHatHat"/>
</member>
<member name="M:Tensor.Tensor`1.op_HatHatHatHat(Tensor.Tensor{System.Boolean},System.Boolean)">
 <summary>Element-wise loigcal xor with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_HatHatHatHat"/>
</member>
<member name="M:Tensor.Tensor`1.op_HatHatHatHat(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean})">
 <summary>Element-wise loigcal xor.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [true; true; false; false]
 let b = HostTensor.ofList [true; false; true; false]
 let c = a ^^^^ b // c = [false; true; true; false]
 </code></example>
 <remarks>
 <para>Computes the logical xor of each element of tensor <paramref name="a"/> with the corresponding element 
 of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillXor"/>
</member>
<member name="M:Tensor.Tensor`1.op_GreaterGreaterGreaterGreater(`0,Tensor.Tensor{`0})">
 <summary>Element-wise greater-than test with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_GreaterGreaterGreaterGreater"/>
</member>
<member name="M:Tensor.Tensor`1.op_GreaterGreaterGreaterGreater(Tensor.Tensor{`0},`0)">
 <summary>Element-wise greater-than test with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_GreaterGreaterGreaterGreater"/>
</member>
<member name="M:Tensor.Tensor`1.op_GreaterGreaterGreaterGreater(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise greater-than test.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [2.0; 4.0; 6.0]
 let b = HostTensor.ofList [1.0; 4.0; 7.0]
 let c = a >>>> b // c = [true; false; false]
 </code></example>
 <remarks>
 <para>Test each element of tensor <paramref name="a"/> for being greater than the corresponding element 
 of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage and type.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillGreater``1"/>
</member>
<member name="M:Tensor.Tensor`1.op_GreaterGreaterEqualsEquals(`0,Tensor.Tensor{`0})">
 <summary>Element-wise greater-than-or-equal test with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_GreaterGreaterEqualsEquals"/>
</member>
<member name="M:Tensor.Tensor`1.op_GreaterGreaterEqualsEquals(Tensor.Tensor{`0},`0)">
 <summary>Element-wise greater-than-or-equal test with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_GreaterGreaterEqualsEquals"/>
</member>
<member name="M:Tensor.Tensor`1.op_GreaterGreaterEqualsEquals(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise greater-than-or-equal test.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [2.0; 4.0; 6.0]
 let b = HostTensor.ofList [1.0; 4.0; 7.0]
 let c = a >>== b // c = [true; true; false]
 </code></example>
 <remarks>
 <para>Test each element of tensor <paramref name="a"/> for being greater than or equal to the corresponding element 
 of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage and type.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para> 
 </remarks>
 <seealso cref="FillGreaterOrEqual``1"/>
</member>
<member name="M:Tensor.Tensor`1.op_EqualsEqualsEqualsEquals(`0,Tensor.Tensor{`0})">
 <summary>Element-wise equality test with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_EqualsEqualsEqualsEquals"/>
</member>
<member name="M:Tensor.Tensor`1.op_EqualsEqualsEqualsEquals(Tensor.Tensor{`0},`0)">
 <summary>Element-wise equality test with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_EqualsEqualsEqualsEquals"/>
</member>
<member name="M:Tensor.Tensor`1.op_EqualsEqualsEqualsEquals(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise equality test.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [2.0; 4.0; 6.0]
 let b = HostTensor.ofList [1.0; 4.0; 7.0]
 let c = a ==== b // c = [false; true; false]
 </code></example>
 <remarks>
 <para>Test each element of tensor <paramref name="a"/> for being equal to the corresponding element 
 of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage and type.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillEqual``1"/>
</member>
<member name="M:Tensor.Tensor`1.op_DotMultiply(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Computes the (batched) matrix product, (batched) matrix-vector product or scalar product.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 // Scalar product
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let b = HostTensor.ofList [2.0; 3.0; 4.0]
 let c = a .* b // c = [56.0]

 // Matrix-vector product
 let a = HostTensor.ofList2D [[5.0; 6.0; 7.0]
                              [8.0; 9.0; 0.0]]
 let b = HostTensor.ofList [2.0; 3.0; 4.0]
 let c = a .* b // c = [56.0; 43.0]

 // Matrix product
 let a = HostTensor.ofList2D [[5.0; 6.0; 7.0]
                              [8.0; 9.0; 0.0]]
 let b = HostTensor.ofList2D [[2.0; 1.0] 
                              [3.0; 1.0]
                              [4.0; 1.0]]
 let c = a .* b // c = [[56.0; 18.0] 
                //      [43.0; 17.0]]
 </code></example>
 <remarks>
 <para>If <paramref name="a"/> and <paramref name="b"/> are vectors of the same length, then the scalar
 product is computed. The result is a scalar.</para>
 <para>If <paramref name="a"/> is a matrix and <paramref name="b"/> is a vector of compatible shape, then 
 the matrix-vector product is computed. The result is a vector.</para>
 <para>If both <paramref name="a"/> and <paramref name="b"/> are matrices of compatibles shapes, then
 the matrix product is computed. The result is a matrix.</para>
 <para>If <paramref name="a"/> is a tensor of shape <c>[b_1; ...; b_n; i; j]</c> and <paramref name="b"/> 
 is a tensor of shape <c>[b_1; ...; b_n; j]</c>, then the batched matrix-vector product is computed resulting in
 a tensor of shape <c>[b_1; ...; b_n; i]</c>. Broadcasting rules apply for the batch dimensions.</para>
 <para>If <paramref name="a"/> is a tensor of shape <c>[b_1; ...; b_n; i; j]</c> and <paramref name="b"/> 
 is a tensor of shape <c>[b_1; ...; b_n; j; k]</c>, then the batched matrix product is computed resulting in
 a tensor of shape <c>[b_1; ...; b_n; i; k]</c>. Broadcasting rules apply for the batch dimensions.</para>
 </remarks>
 <seealso cref="FillDot"/>
</member>
<member name="M:Tensor.Tensor`1.op_Division(`0,Tensor.Tensor{`0})">
 <summary>Element-wise division with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_Division"/>
</member>
<member name="M:Tensor.Tensor`1.op_Division(Tensor.Tensor{`0},`0)">
 <summary>Element-wise division with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_Division"/>
</member>
<member name="M:Tensor.Tensor`1.op_Division(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise division.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let b = HostTensor.ofList [2.0; 3.0; 4.0]
 let c = a / b // c = [2.5; 2.0; 1.75]
 </code></example>
 <remarks>
 <para>Divides each element of tensor <paramref name="a"/> by the corresponding element of tensor <paramref name="b"/>
 and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same type and storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillDivide"/>
</member>
<member name="M:Tensor.Tensor`1.op_BarBarBarBar(System.Boolean,Tensor.Tensor{System.Boolean})">
 <summary>Element-wise loigcal or with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_BarBarBarBar"/>
</member>
<member name="M:Tensor.Tensor`1.op_BarBarBarBar(Tensor.Tensor{System.Boolean},System.Boolean)">
 <summary>Element-wise loigcal or with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_BarBarBarBar"/>
</member>
<member name="M:Tensor.Tensor`1.op_BarBarBarBar(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean})">
 <summary>Element-wise loigcal or.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [true; true; false; false]
 let b = HostTensor.ofList [true; false; true; false]
 let c = a |||| b // c = [true; true; true; false]
 </code></example>
 <remarks>
 <para>Computes the logical or of each element of tensor <paramref name="a"/> with the corresponding element 
 of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillOr"/>
</member>
<member name="M:Tensor.Tensor`1.op_AmpAmpAmpAmp(System.Boolean,Tensor.Tensor{System.Boolean})">
 <summary>Element-wise loigcal and with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_AmpAmpAmpAmp"/>
</member>
<member name="M:Tensor.Tensor`1.op_AmpAmpAmpAmp(Tensor.Tensor{System.Boolean},System.Boolean)">
 <summary>Element-wise loigcal and with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_AmpAmpAmpAmp"/>
</member>
<member name="M:Tensor.Tensor`1.op_AmpAmpAmpAmp(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean})">
 <summary>Element-wise loigcal and.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [true; true; false; false]
 let b = HostTensor.ofList [true; false; true; false]
 let c = a &amp;&amp;&amp;&amp; b // c = [true; false; false; false]
 </code></example>
 <remarks>
 <para>Computes the logical and of each element of tensor <paramref name="a"/> with the corresponding element 
 of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillAnd"/>
</member>
<member name="M:Tensor.Tensor`1.op_Addition(`0,Tensor.Tensor{`0})">
 <summary>Element-wise addition with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_Addition"/>
</member>
<member name="M:Tensor.Tensor`1.op_Addition(Tensor.Tensor{`0},`0)">
 <summary>Element-wise addition with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="op_Addition"/>
</member>
<member name="M:Tensor.Tensor`1.op_Addition(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise addition.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let b = HostTensor.ofList [2.0; 3.0; 4.0]
 let c = a + b // c = [7.0; 9.0; 11.0]
 </code></example>
 <remarks>
 <para>Adds each element of tensor <paramref name="a"/> to the corresponding element of tensor <paramref name="b"/>
 and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same type and storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillAdd"/>
</member>
<member name="M:Tensor.Tensor`1.onesLike(Tensor.Tensor{`0})">
 <summary>Creates a new tensor filled with ones using the specified tensor as template.</summary>
 <param name="tmpl">The template tensor.</param>
 <returns>The new tensor.</returns>
 <remarks>
 <para>A new tensor is created with the same shape and on the same device as <paramref name="tmpl"/>.</para>
 <para>The tensor is filled with ones.</para>
 </remarks>
 <seealso cref="ones"/>
</member>
<member name="M:Tensor.Tensor`1.ones(Tensor.Backend.ITensorDevice,Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new tensor filled with ones (1).</summary>
 <param name="dev">The device to create the tensor on.</param>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <example><code language="fsharp">
 let a = Tensor&lt;float&gt;.ones HostTensor.Dev [2L; 3L]
 // a = [[1.0; 1.0; 1.0]
 //      [1.0; 1.0; 1.0]]
 </code></example>      
 <remarks>
 <para>A new tensor of the specified shape is created on the specified device.</para>
 <para>The tensor is filled with ones.</para>
 </remarks>
 <seealso cref="onesLike"/><seealso cref="zeros"/>    
</member>
<member name="M:Tensor.Tensor`1.ofBlocks(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{`0}}}})">
 <summary>Builds a three dimensional tensor out of tensor blocks.</summary>
 <param name="bs">The tensor blocks.</param>    
 <returns>The resulting tensor.</returns>
 <remarks>    
 <para>The contents of each list are jointed along the dimension determined by its nesting level, i.e. 
 the elements of the outer-most lists are concatenated along dimension zero and the elements of the middle lists
 are concatenated along dimension one and the elements of the inner-most lists are concatenated along dimension
 two.</para>
 <para>The contents of a list must have equal sizes in all dimensions except for the 
 concatenation dimensions.</para>
 </remarks>    
</member>
<member name="M:Tensor.Tensor`1.ofBlocks(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{`0}}})">
 <summary>Builds a matrix out of matrix blocks.</summary>
 <param name="bs">The matrix blocks.</param>    
 <returns>The resulting matrix.</returns>
 <example><code language="fsharp">
 // Consider a block matrix of the follow structure.
 // +-----------------------------+---------------+
 // |                             |               |
 // |                             |               |
 // |            b1               |      b2       |        
 // |         (5 x 28)            |   (5 x 15)    |
 // |                             |               |
 // +---------------------+-------+-------+-------+        
 // |                     |               |       |
 // |       b3            |      b4       |  b5   |
 // |    (3 x 22)         |    (3 x 14)   |(3 x 7)|
 // +---------------------+---------------+-------+        
 //
 // It can be specified as follows.
 let b1 = HostTensor.zeros [5L; 28L]
 let b2 = HostTensor.zeros [5L; 15L]
 let b3 = HostTensor.zeros [3L; 22L]
 let b4 = HostTensor.zeros [3L; 14L]
 let b5 = HostTensor.zeros [3L; 7L]
 let bs = [[b1;   b2  ]
           [b3; b4; b5]]
 let a = Tensor.ofBlocks bs
 // a.Shape = [8L; 43L]
 </code></example>    
 <remarks>    
 <para>The contents of each list are jointed along the dimension determined by its nesting level, i.e. 
 the elements of the outer lists are concatenated along dimension zero (rows) and the elements of the inner lists
 are concatenated along dimension one (columns).</para>
 <para>The contents of a list must have equal sizes in all dimensions except for the 
 concatenation dimensions.</para>
 </remarks>    
</member>
<member name="M:Tensor.Tensor`1.ofBlocks(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{`0}})">
 <summary>Builds a vector out of vectors blocks.</summary>
 <param name="bs">The block vector specification.</param>    
 <returns>The resulting vector.</returns>
 <example><code language="fsharp">
 // Consider a block vector of the follow structure.
 // +-----------------------------+---------------+
 // |          b1 (28)            |    b2 (15)    |
 // +-----------------------------+---------------+        
 //
 // It can be specified as follows.
 let b1 = HostTensor.zeros [28L]
 let b2 = HostTensor.zeros [15L]
 let a = Tensor.ofBlocks [b1; b2]
 // a.Shape = [43L]
 </code></example>    
 <remarks>    
 <para>The contents of a the vectors are concatenated.</para>
 </remarks>    
</member>
<member name="M:Tensor.Tensor`1.ofBlocks(Tensor.BlockTensor{`0})">
 <summary>Builds a tensor out of tensor blocks.</summary>
 <param name="bs">The block tensor specification.</param>    
 <returns>The resulting tensor.</returns>
 <example><code language="fsharp">
 // Consider a block matrix of the follow structure.
 // +-----------------------------+---------------+
 // |                             |               |
 // |                             |               |
 // |            b1               |      b2       |        
 // |         (5 x 28)            |   (5 x 15)    |
 // |                             |               |
 // +---------------------+-------+-------+-------+        
 // |                     |               |       |
 // |       b3            |      b4       |  b5   |
 // |    (3 x 22)         |    (3 x 14)   |(3 x 7)|
 // +---------------------+---------------+-------+        
 //
 // It can be specified as follows.
 let b1 = HostTensor.zeros [5L; 28L]
 let b2 = HostTensor.zeros [5L; 15L]
 let b3 = HostTensor.zeros [3L; 22L]
 let b4 = HostTensor.zeros [3L; 14L]
 let b5 = HostTensor.zeros [3L; 7L]
 let r1 = SubBlocks [Block b1; Block b2]
 let r2 = SubBlocks [Block b3; Block b4; Block b5]
 let a = Tensor.ofBlocks (SubBlocks [r1; r2])
 // a.Shape = [8L; 43L]
 </code></example>    
 <remarks>    
 <para>The contents of a sub-block are jointed along the dimension determined by its nesting level, i.e. 
 a sub-block nested <c>n</c> levels within other sub-blocks will be concatenated along dimension <c>n</c>.</para>
 <para>The contents of a sub-block must have equal sizes in all dimensions except for the 
 concatenation dimensions.</para>
 </remarks>    
 <seealso cref="concat"/>
</member>
<member name="M:Tensor.Tensor`1.normAxis(System.Int32,Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{`0})">
 <summary>Calculates the norm along the specified axis.</summary>
 <param name="axis">The axis to operate along.</param>
 <param name="a">The tensor containing the source values.</param>    
 <param name="ord">The order (power) of the norm. (default: 2)</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.normAxis (1, a) // [5.477; 13.191]
 </code></example>
 <remarks>
 <para>The norm is calculated along the specified axis.</para>
 <para>It is defined by <c>sqrt (sum_i (x_i**ord))</c>.</para>
 </remarks>
 <seealso cref="norm"/>
</member>
<member name="M:Tensor.Tensor`1.norm(Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{`0})">
 <summary>Calculates the norm of the (flattened) tensor.</summary>
 <param name="a">The tensor containing the source values.</param>    
 <param name="ord">The order (power) of the norm. (default: 2)</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.norm a // 14.283
 </code></example>
 <remarks>
 <para>The norm is calculated over all elements of the tensor.</para>
 <para>It is defined by <c>sqrt (sum_i (x_i**ord))</c>.</para>
 </remarks>
 <seealso cref="normAxis"/>
</member>
<member name="M:Tensor.Tensor`1.nElems(Tensor.Tensor{`0})">
 <summary>Total number of elements within the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Number of elements.</returns>
 <seealso cref="NElems"/>
</member>
<member name="M:Tensor.Tensor`1.nDims(Tensor.Tensor{`0})">
 <summary>Dimensionality of the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Number of dimensions.</returns>
 <seealso cref="NDims"/>
</member>
<member name="M:Tensor.Tensor`1.minTensor(Tensor.Tensor{`0})">
 <summary>Calculates the minimum all elements returning a Tensor.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new scalar tensor containing the result of this operation.</returns>
 <seealso cref="min"/>
</member>
<member name="M:Tensor.Tensor`1.minElemwise(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise minimum.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let b = HostTensor.ofList [2.0; 3.0; 4.0]
 let c = Tensor.minElemwise a b // c = [2.0; 3.0; 4.0]
 </code></example>
 <remarks>
 <para>Finds the minimum of each element of tensor <paramref name="a"/> and the corresponding element of 
 tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same type and storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillMinElemwise"/>
</member>
<member name="M:Tensor.Tensor`1.minAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Calculates the minimum value of the elements along the specified axis.</summary>
 <param name="ax">The axis to calculate the minimum along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.minAxis 1 a // b = [1.0; 5.0]
 </code></example>
 <remarks>The minimum is calculated along the specified axis. An empty minimum gives the largest possible value 
 of the used data type.</remarks>
 <seealso cref="FillMinAxis"/><seealso cref="min"/>
</member>
<member name="M:Tensor.Tensor`1.min(Tensor.Tensor{`0})">
 <summary>Calculates the minimum of all elements.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A scalar containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.min a // b = 1.0
 </code></example>
 <remarks>The minimum of all elements is calculated. An empty minimum gives the largest possible value 
 of the used data type.</remarks>
 <seealso cref="minAxis"/><seealso cref="minTensor"/>
</member>
<member name="M:Tensor.Tensor`1.meanAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Calculates the mean of the elements along the specified axis.</summary>
 <param name="ax">The axis to operate along.</param>
 <param name="a">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.meanAxis 1 a // b = [2.5; 6.5]
 </code></example>
 <remarks>The mean is calculated along the specified axis.</remarks>
 <seealso cref="mean"/><seealso cref="varAxis"/><seealso cref="stdAxis"/>
</member>
<member name="M:Tensor.Tensor`1.mean(Tensor.Tensor{`0})">
 <summary>Calculates the mean of the tensor.</summary>
 <param name="a">The tensor containing the source values.</param>    
 <returns>The mean estimate.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.mean a // b = 4.5
 </code></example>
 <remarks>The mean is calculated over all elements of the tensor.</remarks>
 <seealso cref="meanAxis"/><seealso cref="var"/><seealso cref="std"/>
</member>
<member name="M:Tensor.Tensor`1.maxTensor(Tensor.Tensor{`0})">
 <summary>Calculates the maximum all elements returning a Tensor.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new scalar tensor containing the result of this operation.</returns>
 <seealso cref="max"/> 
</member>
<member name="M:Tensor.Tensor`1.maxElemwise(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise maximum.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let b = HostTensor.ofList [2.0; 3.0; 4.0]
 let c = Tensor.maxElemwise a b // c = [5.0; 6.0; 7.0]
 </code></example>
 <remarks>
 <para>Finds the maximum of each element of tensor <paramref name="a"/> and the corresponding element of 
 tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same type and storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillMaxElemwise"/>
</member>
<member name="M:Tensor.Tensor`1.maxAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Calculates the maximum value of the elements along the specified axis.</summary>
 <param name="ax">The axis to calculate the maximum along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.maxAxis 1 a // b = [4.0; 8.0]
 </code></example>
 <remarks>The maximum is calculated along the specified axis. An empty maximum gives the smallest possible value 
 of the used data type.</remarks>
 <seealso cref="FillMaxAxis"/><seealso cref="max"/>
</member>
<member name="M:Tensor.Tensor`1.max(Tensor.Tensor{`0})">
 <summary>Calculates the maximum of all elements.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A scalar containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.min a // b = 8.0
 </code></example>
 <remarks>The maximum of all elements is calculated. An empty maximum gives the smallest possible value 
 of the used data type.</remarks>
 <seealso cref="maxAxis"/><seealso cref="maxTensor"/>
</member>
<member name="M:Tensor.Tensor`1.linspace(Tensor.Backend.ITensorDevice,`0,`0,System.Int64)">
 <summary>Creates a new vector of given size filled with equaly spaced values.</summary>
 <param name="dev">The device to create the tensor on.</param>
 <param name="start">The starting value.</param>
 <param name="stop">The end value, which is not included.</param>
 <param name="nElems">The size of the vector.</param>   
 <returns>The new tensor.</returns>
 <example><code language="fsharp">
 let a = Tensor.linspace HostTensor.Dev 1.0 2.0 5L
 // a = [1.0; 1.2; 1.4; 1.6; 1.8]
 </code></example>        
 <remarks>
 <para>A new vector with <paramref name="nElems"/> elements is created on the specified device.</para>
 <para>The vector is filled with <c>[start; start+1*incr; start+2*incr; ...; stop]</c> where
 <c>incr = (stop - start) / (nElems - 1)</c>.</para>
 </remarks>
 <seealso cref="arange``1"/>
</member>
<member name="M:Tensor.Tensor`1.layout(Tensor.Tensor{`0})">
 <summary>Memory layout of the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Memory layout.</returns>
 <seealso cref="Layout"/>
</member>
<member name="M:Tensor.Tensor`1.isFinite(Tensor.Tensor{`0})">
 <summary>Element-wise finity check (not -Inf, Inf or NaN).</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-infinity; -3.0; nan; 3.0; infinity]
 let b = isFinite a // b = [false; true; false; true; false]
 </code></example>
 <remarks>Checks each element of the specified tensor for finity (not -Inf, Inf or NaN) and returns
 the results as a new tensor of type <c>bool</c>.</remarks>
 <seealso cref="FillIsFinite``1"/><seealso crf="allFinite``1"/>
</member>
<member name="M:Tensor.Tensor`1.isClose(Tensor.Tensor{`0},Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{`0},Microsoft.FSharp.Core.FSharpOption{`0})">
 <summary>Element-wise check if two tensors have same (within machine precision) values.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <param name="absTol">The absolute tolerance. (default 1e-8)</param>
 <param name="relTol">The relative tolerance. (default 1e-5)</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <remarks>
 <para>Test each element of tensor <paramref name="a"/> for being almost equal to the corresponding element 
 of tensor <paramref name="b"/> and returns the results as a new tensor. For integer data types the check
 is exact.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage and type.</para>
 </remarks>
 <seealso crf="almostEqual``1"/>
</member>
<member name="M:Tensor.Tensor`1.isBroadcasted(Tensor.Tensor{`0})">
 <summary>Checks if the specified tensor is broadcasted in at least one dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>true if at least one dimension is broadcasted, otherwise false.</returns>
 <remarks>
 <para>If any stride is zero, it is assumed that the tensor is broadcasted.
 If this is the case, changing an element of the tensor may change other elements as well.</para>    
 </remarks>
 <seealso cref="broadcastToSame``2"/><seealso cref="broadcastTo"/>
</member>
<member name="M:Tensor.Tensor`1.invert(Tensor.Tensor{`0})">
 <summary>(Batch) inverts a matrix.</summary>
 <param name="a">The input matrix or tensor to this operation.</param>
 <returns>A new matrix or tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0]
                            [3.0; 4.0]]
 let c = Tensor.invert a // c = [[-2.0; 1.0]    
                         //      [1.5; -0.5]]  
 </code></example>
 <remarks>
 <para>If <paramref name="a"/> is a square matrix, its inverse is computed. The result is a matrix.</para>
 <para>If <paramref name="a"/> is a tensor of shape <c>[b_1; ...; b_n; i; i]</c>, the inverse
 of all square matrices consisting of the last two dimensions of the tensor are computed. 
 The result is a tensor of same shape.</para>
 <para>If the matrix is not invertible a <see cref="Tensor.SingularMatrixException"/> is raised.
 Use <see cref="pseudoInvert"/> for such matrices instead.</para>
 </remarks>
 <exception cref="Tensor.SingularMatrixException">Raised when the matrix is not invertible.</exception>
 <seealso cref="FillInvert"/><seealso cref="pseudoInvert"/>         
</member>
<member name="M:Tensor.Tensor`1.insertAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Insert a dimension of size one before the specifed dimension.</summary>
 <param name="ax">The dimension to insert before.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [3L; 4L; 5L]
 let b = Tensor.insertAxis 1 a // b.Shape = [3L; 1L 4L; 5L]
 </code></example>    
 <remarks>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <seealso cref="padLeft"/><seealso cref="padRight"/>
</member>
<member name="M:Tensor.Tensor`1.ifThenElse(Tensor.Tensor{System.Boolean},Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise choice between two sources depending on a condition.</summary>
 <param name="cond">The condition tensor.</param>
 <param name="ifTrue">The tensor containing the values to use for when an element of the condition is true.</param>
 <param name="ifFalse">The tensor containing the values to use for when an element of the condition is false.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let cond = HostTensor.ofList [true; false; false]
 let ifTrue = HostTensor.ofList [2.0; 3.0; 4.0]
 let ifFalse = HostTensor.ofList [5.0; 6.0; 7.0]
 let target = Tensor.ifThenElse cond ifTrue ifFalse // target = [2.0; 6.0; 7.0]
 </code></example>
 <remarks>
 <para>Evaluates each element of tensor <paramref name="cond"/>. If it evaluates to true, the corresponding
 element of tensor <paramref name="ifTrue"/> is written into the result. Otherwise, the corresponding element
 of tensor <paramref name="ifFalse"/> is written into the result.</para>
 <para>The tensors <paramref name="cond"/>, <paramref name="ifTrue"/> and <paramref name="ifFalse"/> must have 
 the same storage.
 Broadcasting rules apply if <paramref name="cond"/>, <paramref name="ifTrue"/> and <paramref name="ifFalse"/> 
 have different shapes.</para>
 </remarks>
 <seealso cref="FillIfThenElse"/>
</member>
<member name="M:Tensor.Tensor`1.identity(Tensor.Backend.ITensorDevice,System.Int64)">
 <summary>Creates a new identity matrix.</summary>
 <param name="dev">The device to create the matrix on.</param>
 <param name="size">The size of the square identity matrix.</param>
 <returns>The new tensor.</returns>
 <example><code language="fsharp">
 let a = Tensor&lt;float&gt;.identity HostTensor.Dev 3L
 // a = [[1.0; 0.0; 0.0]
 //      [0.0; 1.0; 0.0]
 //      [0.0; 0.0; 1.0]]    
 </code></example>         
 <remarks>
 <para>A new square matrix of the specified size is created on the specified device.</para>
 <para>The tensor is filled with ones on the diagonal and zeros elsewhere.</para>
 </remarks>
</member>
<member name="P:Tensor.Tensor`1.Value">
 <summary>Accesses the value of a zero-dimensional (scalar) tensor.</summary>
 <value>The scalar value of the tensor.</value>
 <example><code language="fsharp">
 let a = HostTensor.sclar 2.0
 let b = a.Value // 2.0
 a.Value &lt;- 3.0 // a = 3.0
 </code></example>
 <remarks>
 <para>Gets or sets the value of a scalar tensor.</para>
 <para>The tensor must have zero dimensions.</para>
 </remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the tensor is not zero-dimensional.</exception>
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{System.Int64})"/>
</member>
<member name="P:Tensor.Tensor`1.T">
 <summary>Transpose of a matrix.</summary>
 <value>The transposed matrx.</value>
 <example><code language="fsharp">
 let a = HostTensor.zeros [3L; 5L]
 let b = a.T // b.Shape = [5L; 3L]
 </code></example>    
 <remarks>
 <para>If the given tensor has more then two dimensions, the last two axes are swapped.</para>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <seealso cref="permuteAxes"/><seealso cref="swapDim"/>    
</member>
<member name="P:Tensor.Tensor`1.Storage">
 <summary>The storage object that holds the data of this tensor.</summary>
 <value>Storage object.</value>
 <remarks>
 <para>The storage object holds the actual data of the tensor.
 A storage object can be associated with one or more tensors, i.e. it can be shared between multiple tensors.
 Sharing occurs, for example, when a view into an existing tensor is created or the tensor is reshapred.</para>
 <para>The actual type of the storage object depends on the device the data of the tensor is stored on.</para>
 <para>For tensors stored in host memory the storage object type is <see cref="Tensor.Host.TensorHostStorage`1"/>.</para>
 <para>For tensors stored on a CUDA GPU the storage object type is <see cref="Tensor.Cuda.TensorCudaStorage`1"/>.</para>
 </remarks>
 <seealso cref="Dev"/><seealso cref="Layout"/>
</member>
<member name="P:Tensor.Tensor`1.Shape">
 <summary>Shape of this tensor.</summary>
 <value>Shape.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0; 5.0]
                            [3.0; 4.0; 6.0]]
 let c = a.Shape // [2L; 3L]
 </code></example>
 <remarks>
 <para>Provides the shape of this tensor.</para>
 <para>A tensor is empty of any dimension has size zero.</para>
 <para>A zero-dimensional tensor has an empty shape and contains one element.</para>
 </remarks>
 <seealso cref="reshape"/><seealso cref="NDims"/><seealso cref="NElems"/>
</member>
<member name="P:Tensor.Tensor`1.Pretty">
 <summary>String representation of the tensor limited to 10 elements per dimension.</summary>
 <value>A (shortened) string representation of this tensor</value>
 <seealso cref="ToString(System.Int64)"/><seealso cref="Full"/>
</member>
<member name="P:Tensor.Tensor`1.NElems">
 <summary>Total number of elements within this tensor.</summary>
 <value>Number of elements.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0; 5.0]
                            [3.0; 4.0; 6.0]]
 let c = a.NElems // 6L
 </code></example>
 <remarks>
 <para>Counts the total number of elements of this tensor.</para>
 <para>A zero-dimensional tensor contains one element, i.e. it is a scalar.</para>
 </remarks>
 <seealso cref="Shape"/>
</member>
<member name="P:Tensor.Tensor`1.NDims">
 <summary>Dimensionality of this tensor.</summary>
 <value>Number of dimensions.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0; 5.0]
                            [3.0; 4.0; 6.0]]
 let c = a.NDims // 2
 </code></example>
 <remarks>
 <para>Provides the number of dimensions of this tensor.</para>
 <para>A zero-dimensional tensor contains one element, i.e. it is a scalar.</para>
 </remarks>
 <seealso cref="Shape"/>
</member>
<member name="P:Tensor.Tensor`1.M(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{System.Boolean}})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="masks">A list of boolean mask tensors or <see cref="Tensor.NoMask"/>.</param>
 <value>All elements from the tensor for which the mask is true.</value>
 <remarks>
 <para>Masking picks elements from the tensor for which the corresponding element in the mask tensor is true.
 The mask can, for example, be generated by one or more element-wise comparison operation.</para>
 <para>The get operation returns a copy of the selected elements of the tensor.</para>
 <para>The set operation replaces the selected elements with a copy of the specified tensor.</para>
 <para>If a dimension should not be masked, specify <see cref="Tensor.NoMask"/> instead of a mask tensor.</para>
 <para>This mask specification variant is intended for programmatically generated ranges. For most use cases
 the variant <seealso cref="M(Tensor.Tensor{System.Boolean})"/> is more succinct and thus the 
 recommended method.</para>    
 </remarks>
 <exception cref="System.InvalidArgumentException">Raised when the mask is incompatible with the tensor.</exception>
 <seealso cref="M(Tensor.Tensor{System.Boolean})"/>
</member>
<member name="P:Tensor.Tensor`1.M(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="m0">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m1">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m2">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m3">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>    
 <param name="m4">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>    
</member>
<member name="P:Tensor.Tensor`1.M(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="m0">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m1">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m2">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m3">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>    
</member>
<member name="P:Tensor.Tensor`1.M(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="m0">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m1">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m2">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>    
</member>
<member name="P:Tensor.Tensor`1.M(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="m0">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <param name="m1">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
</member>
<member name="P:Tensor.Tensor`1.M(Tensor.Tensor{System.Boolean})">
 <summary>Picks elements from a tensor using one or more boolean mask tensors.</summary>
 <param name="m0">A boolean mask tensor or <see cref="Tensor.NoMask"/>.</param>
 <value>All elements from the tensor for which the mask is true.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0; 3.0]
                            [4.0; 5.0; 6.0]]

 // masked get with one mask for the whole tensor
 let m = HostTensor.ofList [[true;  true;  false]
                            [false; false; true ]]
 let b = a.M(m) // b = [1.0; 2.0; 6.0]

 // an element-wise comparison operator can be used to create the mask
 let c = a.M(a >>>> 3.5) // c = [4.0; 5.0; 6.0]

 // masked get with one mask per dimension
 let m0 = HostTensor.ofList [true; false]
 let m1 = HostTensor.ofList [false; false; true]
 let d = a.M(m0, m1) // d = [3.0]

 // masked get using only one dimension
 let m0 = HostTensor.ofList [true; false]
 let e = a.M(m0, NoMask) // e = [[1.0; 2.0; 3.0]]

 // masked set with one mask for the whole tensor
 let m = HostTensor.ofList [[true;  true;  false]
                            [false; false; true ]]
 a.M(m) &lt;- [8.0; 9.0; 0.0]  // a = [[8.0; 9.0; 3.0]
                            //      [4.0; 5.0; 0.0]]
 </code></example>    
 <remarks>
 <para>Masking picks elements from the tensor for which the corresponding element in the mask tensor is true.
 The mask can, for example, be generated by one or more element-wise comparison operation.</para>
 <para>The get operation returns a copy of the selected elements of the tensor.</para>
 <para>The set operation replaces the selected elements with a copy of the specified tensor.</para>
 <para>If a dimension should not be masked, specify <see cref="Tensor.NoMask"/> instead of a mask tensor.</para>
 <para>For clarity the documentation does not list all overloads of <c>M</c>.
 However, this masking method can be used for up to 5 dimensions, as shown in the example.
 For programmatically generated ranges or for more than 5 dimensions, the mask specification variant 
 <see cref="M(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{System.Boolean}})"/> is available.</para>
 <para>Currently this operation is only supported for tensors stored on the host. Support for CUDA tensors is
 planned in the future.</para>
 </remarks>
 <exception cref="System.InvalidArgumentException">Raised when the mask is incompatible with the tensor.</exception>
 <seealso cref="M(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{System.Boolean}})"/>
</member>
<member name="P:Tensor.Tensor`1.Layout">
 <summary>Memory layout of this tensor.</summary>
 <value>Memory layout.</value>
 <remarks>Provides information of how the data is stored within this tensor.</remarks>
 <seealso cref="Storage"/><seealso cref="Shape"/>
</member>
<member name="P:Tensor.Tensor`1.Item(System.Int64)">
 <summary>Accesses a slice (part) of the tensor.</summary>
 <param name="i0">The range of the tensor to select.</param>
 <value>A view of the selected part of the tensor.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0; 3.0]
                            [4.0; 5.0; 6.0]]

 // get view
 let b = a.[0L, 1L] // b = 2.0
 let c = a.[0L, *] // b = [1.0; 2.0; 3.0]
 let d = a.[1L, 0L..1L] // b = [4.0; 5.0]
 let e = a.[1L..1L, 0L..1L] // b = [[4.0; 5.0]]

 // set view
 a.[0L, *] &lt;- HostTensor.ofList [7.0; 8.0; 9.0] // a = [[7.0; 8.0; 9.0]
                                                //      [4.0; 5.0; 6.0]]

 // modifiying view affects original tensor
 d.[[1L]] &lt;- 0.0 // a = [[7.0; 8.0; 9.0]
                 //      [4.0; 0.0; 6.0]]
 </code></example>    
 <remarks>
 <para>Indexing is zero-based.</para>
 <para>This indexing options allows to select a part (called slice) of the tensor.</para>
 <para>The get operation returns a view of the specified part of the tensor. Modifications done to that
 view will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 <para>The slicing specifications follows standard F# practice. 
 Specifying an integer for the index of a dimension, selects that index for the dimension.
 Specifying <c>*</c> for a dimension, selects all indices of the dimension.
 Specifying <c>f..l</c> for a dimension, select all indices from <c>f</c> to (including) <c>l</c> for the dimension.
 </para>
 <para>For clarity the documentation does not list all overloads of the Item property and GetSlice, 
 SetSlice methods. However, this slicing method can be used for up to 5 dimensions, as shown in the example.
 For programmatically generated ranges or for more than 5 dimensions, the range specification variant 
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng})"/> is available.</para>
 </remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the specified range is out of range.</exception>
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng})"/>
</member>
<member name="P:Tensor.Tensor`1.Item(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng})">
 <summary>Accesses a slice (part) of the tensor.</summary>
 <param name="rng">The range of the tensor to select.</param>
 <value>A view of the selected part of the tensor.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0; 3.0]
                            [4.0; 5.0; 6.0]]

 // get view
 let b = a.[[Rng.Elem 0L; Rng.Elem 1L]] // b = 2.0
 let c = a.[[Rng.Elem 0L; Rng.All]] // b = [1.0; 2.0; 3.0]
 let d = a.[[Rng.Elem 1L; Rng.Rng (Some 0L, Some 1L)]] // b = [4.0; 5.0]
 let e = a.[[Rng.Rng (Some 1L, Some 1L); Rng (Some 0L, Some 1L)]] // b = [[4.0; 5.0]]

 // set view
 a.[[Rng.Elem 0L; Rng.All]] &lt;- HostTensor.ofList [7.0; 8.0; 9.0] // a = [[7.0; 8.0; 9.0]
                                                                 //      [4.0; 5.0; 6.0]]

 // modifiying view affects original tensor
 d.[[1L]] &lt;- 0.0 // a = [[7.0; 8.0; 9.0]
                 //      [4.0; 0.0; 6.0]]
 </code></example>    
 <remarks>
 <para>This range specification variant is intended for programmatically generated ranges. For most use cases
 the variant <seealso cref="Item(System.Int64)"/> allows vastly simpler range specifications and is the 
 recommended method.</para>
 <para>Indexing is zero-based.</para>
 <para>This indexing options allows to select a part (called slice) of the tensor.</para>
 <para>The get operation returns a view of the specified part of the tensor. Modifications done to that
 view will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 <para>See <see cref="Tensor.Rng"/> for available range specifications.</para>
 </remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the specified range is out of range.</exception>
 <seealso cref="Item(System.Int64)"/>
</member>
<member name="P:Tensor.Tensor`1.Item(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Accesses a single element within the tensor.</summary>
 <param name="idx">A list consisting of the indicies of the element to access. The list must have one entry
 per dimension of this tensor.</param>
 <value>The value of the selected element.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0]
                            [3.0; 4.0]]
 let b = a.[[1L; 1L]] // b = 4.0
 a.[[1L; 0L]] &lt;- 6.0 // a = [[1.0; 2.0]
                     //      [6.0; 4.0]]                        
 </code></example>    
 <remarks>
 <para>Indexing is zero-based.</para>
 <para>Use <see cref="Item(System.Int64[])"/> for faster element access.</para>
 </remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the specified indicies are out of range.</exception>
 <seealso cref="Item(System.Int64[])"/><seealso cref="Value"/>
</member>
<member name="P:Tensor.Tensor`1.Item(System.Int64[])">
 <summary>Accesses a single element within the tensor.</summary>
 <param name="idx">An array consisting of the indicies of the element to access. The arry must have one entry
 per dimension of this tensor.</param>
 <value>The value of the selected element.</value>
 <example><code language="fsharp">
 let a = HostTensor.ofList [[1.0; 2.0]
                            [3.0; 4.0]]
 let b = a.[[|1L; 1L|]] // b = 4.0
 a.[[|1L; 0L|]] &lt;- 6.0 // a = [[1.0; 2.0]
                       //      [6.0; 4.0]]                        
 </code></example>    
 <remarks>
 <para>Indexing is zero-based.</para>
 </remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the specified indicies are out of range.</exception>
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{System.Int64})"/>
</member>
<member name="P:Tensor.Tensor`1.Full">
 <summary>Unabreviated string representation of the tensor.</summary>
 <value>An unabreviated string representation of this tensor</value>
 <seealso cref="ToString(System.Int64)"/><seealso cref="Pretty"/>
</member>
<member name="P:Tensor.Tensor`1.Dev">
 <summary>Device the data of tensor is stored on.</summary>
 <value>Data storage device.</value>
 <remarks>
 <para>For tensors stored in host memory the value of this property is <see cref="HostTensor.Dev"/>.</para>
 <para>For tensors stored on a CUDA GPU the value of this property is <see cref="CudaTensor.Dev"/>.</para>
 </remarks>
 <seealso cref="Storage"/>
</member>
<member name="P:Tensor.Tensor`1.DataType">
 <summary>Type of data stored within this tensor.</summary>
 <value>Data type.</value>
 <remarks>
 <para>The data type is <c>typeof&lt;'T&gt;</c>.</para>
 </remarks>
 <seealso cref="convert``1"/>
</member>
<member name="P:Tensor.Tensor`1.Backend">
<summary>
 backend 
</summary>
</member>
<member name="P:Tensor.Tensor`1.AsInt64">
<summary>
 this tensor as Tensor&lt;int64&gt;
</summary>
</member>
<member name="P:Tensor.Tensor`1.AsBool">
<summary>
 this tensor as Tensor&lt;bool&gt;
</summary>
</member>
<member name="M:Tensor.Tensor`1.get(Tensor.Tensor{`0},Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Gets the value of a single element of the tensor.</summary>
 <param name="a">The tensor to read from.</param>
 <param name="pos">A list consisting of the indicies of the element to access. The list must have one entry
 per dimension of this tensor.</param>
 <returns>The value of the selected element.</returns>
 <seealso cref="Item(Microsoft.FSharp.Collections.FSharpList{System.Int64})"/>
</member>
<member name="M:Tensor.Tensor`1.gather(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{Tensor.Tensor{System.Int64}}},Tensor.Tensor{`0})">
 <summary>Selects elements from a tensor according to specified indices.</summary>
 <param name="indices">A list of tensors, one per dimension of <paramref name="src"/>, containing the indicies
 to pick from <paramref name="src"/> for each output element.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>Result with the shape of the (broadcasted) tensors specified in <paramref name="indices"/>.</returns>
 <example><code language="fsharp">
 let src = HostTensor.ofList2D [[0.0; 0.1; 0.2; 0.3]
                                [1.0; 1.1; 1.2; 1.3]
                                [2.0; 2.1; 2.2; 2.3]]
 let i0 = HostTensor.ofList [1L; 2L; 0L; 0L]
 let i1 = HostTensor.ofList [3L; 1L; 0L; 3L]
 let g = Tensor.gather [Some i0; Some i1] src // g = [1.3000    2.1000    0.0000    0.3000]

 // Using None instead of an index tensor.    
 let j1 = HostTensor.ofList [3L; 1L; 0L]
 let g2 = Tensor.gather [None; Some j1] src // g2 = [0.3000    1.1000    2.0000]
 </code></example>
 <remarks>
 <para>The output element with indices <c>[i_0; i_1; i_2; ...]</c> is given by the source element with indices 
 <c>[j_0; j_1; j_2; ...]</c>, where each index <c>j_k</c> is given by <c>j_k = indices.[k].[i_0; i_1; i_2; ...]</c>.
 If <c>indices.[k]</c> is <c>None</c>, then <c>j_k = i_k</c> is assumed instead.
 Index dimensions beyond the number of target dimensions must not be <c>None</c>.
 </para>
 <para>The tensors <paramref name="indices"/> and <paramref name="src"/> must have the same storage.
 All index tensors are broadcasted to the same size.</para>
 </remarks>
 <seealso cref="FillGather"/><seealso cref="scatter"/>
</member>
<member name="M:Tensor.Tensor`1.flatten(Tensor.Tensor{`0})">
 <summary>Flattens the tensor into a (one-dimensional) vector.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>A vector.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [2L; 3L; 4L]
 let b = Tensor.flatten a // b.Shape = [24L]
 </code></example>    
 <remarks>    
 <para>If a reshape is possible without copying the data of the tensor, a view of the original tensor is returned
 and the storage is shared. In this case, modifications done to the returned tensor will affect the original 
 tensor.</para>
 </remarks>    
 <seealso cref="reshape"/>
</member>
<member name="M:Tensor.Tensor`1.findAxis(`0,System.Int32,Tensor.Tensor{`0})">
 <summary>Finds the first occurence of the specfied value along the specified axis and returns its index.</summary>
 <param name="value">The value to find.</param>
 <param name="ax">The axis to find the value along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the indices of the first occurence of <paramref name="value"/>.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 3.0]]
 let b = Tensor.findAxis 3.0 1 a // b = [2L; 3L]
 </code></example>
 <remarks>The values is searched for an the index of the first occurence is returned.
 If the value is not found <see cref="Tensor.NotFound"/> is returned instead.</remarks>
 <seealso cref="FillFindAxis``1"/>
</member>
<member name="M:Tensor.Tensor`1.find(`0,Tensor.Tensor{`0})">
 <summary>Finds the first occurence of the specfied value and returns its indices.</summary>
 <param name="value">The value to find.</param>
 <param name="a">The tensor containing the source values.</param>    
 <returns>The indices of the value.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 3.0]]
 let b = Tensor.find 3.0 a // b = [0L; 2L]
 </code></example>
 <remarks>The values is searched for an the index of the first occurence is returned.
 If the value is not found, an <see cref="System.InvalidOperationException"/> is raised.
 Use <see cref="tryFind"/> instead, if the value might not be present.
 </remarks>
 <exception cref="System.InvalidOperationException">Raised if value is not found.</exception>
 <seealso cref="tryFind"/><seealso cref="findAxis"/>
</member>
<member name="M:Tensor.Tensor`1.filled(Tensor.Backend.ITensorDevice,Microsoft.FSharp.Collections.FSharpList{System.Int64},`0)">
 <summary>Creates a new tensor filled with the specified value.</summary>
 <param name="dev">The device to create the tensor on.</param>
 <param name="shape">The shape of the new tensor.</param>
 <param name="value">The value to fill the new tensor with.</param>
 <returns>The new tensor.</returns>
 <example><code language="fsharp">
 let a = Tensor.filled HostTensor.Dev [2L; 3L] 1.5
 // a = [[1.5; 1.5; 1.5]
 //      [1.5; 1.5; 1.5]]
 </code></example>         
 <remarks>
 <para>A new tensor of the specified shape is created on the specified device.</para>
 <para>The tensor is filled with the specified value.</para>
 </remarks>
 <seealso cref="FillConst"/>
</member>
<member name="M:Tensor.Tensor`1.falses(Tensor.Backend.ITensorDevice,Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new boolean tensor filled with falses.</summary>
 <param name="dev">The device to create the tensor on.</param>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <example><code language="fsharp">
 let a = Tensor.falses HostTensor.Dev [2L; 3L]
 // a = [[false; false; false]
 //      [false; false; false]]
 </code></example>        
 <remarks>
 <para>A new tensor of the specified shape is created on the specified device.</para>
 <para>The tensor is filled with falses.</para>
 </remarks>
 <seealso cref="trues"/>
</member>
<member name="M:Tensor.Tensor`1.empty(Tensor.Backend.ITensorDevice,System.Int32)">
 <summary>Creates a new, empty tensor with the given number of dimensions.</summary>
 <param name="dev">The device to create the tensor on.</param>
 <param name="nDims">The number of dimensions of the new, empty tensor.</param>
 <returns>The new, empty tensor.</returns>
 <remarks>
 <para>The shape of the tensor is <c>[0L; ...; 0L]</c>. It contains no elements.</para>
 </remarks>
</member>
<member name="M:Tensor.Tensor`1.dot(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Computes the (batched) matrix product, (batched) matrix-vector product or scalar product.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>    
 <seealso cref="op_DotMultiply"/>        
</member>
<member name="M:Tensor.Tensor`1.diffAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Calculates the difference between adjoining elements along the specified axes.</summary>
 <param name="ax">The axis to operate along.</param>
 <param name="a">The tensor containing the source values.</param>    
 <returns>The differences tensor. It has one element less in dimension <paramref name="ax"/> 
 as the input tensor.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [10L; 5L]
 let b = Tensor.diffAxis 0 a // b.Shape = [9L; 5L]
 </code></example>
 <remarks>
 <para>The resulting tensor has one element less in the differentiation dimension than the original tensor.</para>
 </remarks>
 <seealso cref="diff"/>
</member>
<member name="M:Tensor.Tensor`1.diff(Tensor.Tensor{`0})">
 <summary>Calculates the difference between adjoining elements of the vector.</summary>
 <param name="a">The vector containing the source values.</param>    
 <returns>The differences vector. It has one element less than the input tensor.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [5L]
 let b = Tensor.diff a // b.Shape = [4L]
 </code></example>
 <remarks>
 <para>The value of output element <c>i</c> is given by <c>d_i = a_(i+1) - a_i</c>.</para>
 <para>The resulting vector has one element less in the last dimension than the original vector.</para>
 <para>If the input tensor has more than one dimension, this operation is applied batch-wise on the last
 dimension.</para>
 </remarks>
 <seealso cref="diffAxis"/>
</member>
<member name="M:Tensor.Tensor`1.diagMatAxis(System.Int32,System.Int32,Tensor.Tensor{`0})">
 <summary>Creates a tensor with the specified diagonal along the given axes.</summary>
 <param name="ax1">The first dimension of the diagonal.</param>
 <param name="ax2">The seconds dimension of the diagonal.</param>
 <param name="a">The values for the diagonal.</param>    
 <returns>A tensor having the values <paramref name="a"/> on the diagonal specified by the axes 
 <paramref name="ax1"/> and <paramref name="ax2"/>.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [4L; 3L]
 let b = Tensor.diagMatAxis 0 1 a // b.Shape = [4L; 4L; 3L]
 </code></example>    
 <remarks>    
 <para>A new tensor with the same shape as <paramref name="a"/> but with axis <paramref name="ax2"/> inserted
 is created. The size of axis <paramref name="ax2"/> is set to the size of axis <paramref name="ax1"/>.</para>
 <para>The diagonal over axes <paramref name="ax1"/> and <paramref name="ax2"/> is filled with the elements of 
 tensor <paramref name="a"/>. The other elements are set to zero.</para>
 </remarks>    
 <seealso cref="diagMat"/><seealso cref="diagAxis"/>
</member>
<member name="M:Tensor.Tensor`1.diagMat(Tensor.Tensor{`0})">
 <summary>Creates a matrix with the specified diagonal.</summary>
 <param name="a">The vector containing the values for the diagonal.</param>    
 <returns>A matrix having the values <paramref name="a"/> on its diagonal.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [5L]
 let b = Tensor.diag a // b.Shape = [5L; 5L]
 </code></example>    
 <remarks>    
 <para>A square matrix with the same size as <paramref name="a"/> is created.</para>
 <para>The diagonal is filled with the elements of vector <paramref name="a"/>. 
 The other elements are set to zero.</para>
 <para>If the specified tensor has more than one dimension, the operation is
 performed batch-wise on the last dimension.</para>
 </remarks>    
 <seealso cref="diagMatAxis"/><seealso cref="diag"/>
</member>
<member name="M:Tensor.Tensor`1.diagAxis(System.Int32,System.Int32,Tensor.Tensor{`0})">
 <summary>Returns a view of the diagonal along the given axes.</summary>
 <param name="ax1">The first dimension of the diagonal.</param>
 <param name="ax2">The seconds dimension of the diagonal.</param>
 <param name="a">The tensor to operate on.</param>    
 <returns>A tensor where dimension <paramref name="ax1"/> is the diagonal and dimension
 <paramref name="ax2"/> is removed.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [4L; 3L; 3L; 5L]
 let b = Tensor.diagAxis 1 2 a // b.Shape = [4L; 3L; 5L]
 </code></example>    
 <remarks>    
 <para>The dimensions specified by <paramref name="ax1"/> and <paramref name="ax2"/> must have the same size.</para>
 <para>A view of the original tensor is returned and the storage is shared. Modifications done to the returned 
 tensor will affect the original tensor.</para>
 </remarks>    
 <seealso cref="diag"/><seealso cref="diagMatAxis"/>
</member>
<member name="M:Tensor.Tensor`1.diag(Tensor.Tensor{`0})">
 <summary>Returns a view of the diagonal of the matrix.</summary>
 <param name="a">A square matrix.</param>    
 <returns>The diagonal vector.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [3L; 3L]
 let b = Tensor.diag a // b.Shape = [3L]
 </code></example>    
 <remarks>    
 <para>The matrix must be square.</para>
 <para>If the specified tensor has more than two dimensions, the diagonals along the last two dimensions 
 are returned as a tensor.</para>
 <para>A view of the original tensor is returned and the storage is shared. Modifications done to the returned 
 tensor will affect the original tensor.</para>
 </remarks>    
 <seealso cref="diagAxis"/><seealso cref="diagMat"/>
</member>
<member name="M:Tensor.Tensor`1.dev(Tensor.Tensor{`0})">
 <summary>Device the data of tensor is stored on.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Data storage device.</returns>
 <seealso cref="Dev"/><seealso cref="transfer``1"/>
</member>
<member name="M:Tensor.Tensor`1.dataType(Tensor.Tensor{`0})">
 <summary>Type of data stored within the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Data type.</returns>
 <seealso cref="DataType"/>
</member>
<member name="M:Tensor.Tensor`1.cutRight(Tensor.Tensor{`0})">
 <summary>Removes the last dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [3L; 4L; 5L]
 let b = Tensor.cutRight a // b.Shape = [3L; 4L]
 </code></example>    
 <remarks>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <seealso cref="cutLeft"/>
</member>
<member name="M:Tensor.Tensor`1.cutLeft(Tensor.Tensor{`0})">
 <summary>Removes the first dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [3L; 4L; 5L]
 let b = Tensor.cutLeft a // b.Shape = [4L; 5L]
 </code></example>    
 <remarks>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <seealso cref="cutRight"/>
</member>
<member name="M:Tensor.Tensor`1.counting(Tensor.Backend.ITensorDevice,System.Int64)">
 <summary>Creates a new vector filled with the integers from zero to the specified maximum.</summary>
 <param name="dev">The device to create the tensor on.</param>
 <param name="nElems">The number of elements of the new vector.</param>
 <returns>The new tensor.</returns>
 <example><code language="fsharp">
 let a = Tensor.counting HostTensor.Dev 5L
 // a = [0L; 1L; 2L; 3L; 4L]
 </code></example>          
 <remarks>
 <para>A new vector with the specified number of elements is created on the specified device.</para>
 <para>The tensor is filled with <c>[0L; 1L; 2L; ...; nElems-1L]</c>. </para>
 </remarks>
 <seealso cref="arange``1"/>
</member>
<member name="M:Tensor.Tensor`1.countTrueTensor(Tensor.Tensor{System.Boolean})">
 <summary>Counts the elements being true returning the result as a Tensor.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new scalar tensor containing the result of this operation.</returns>
 <seealso cref="countTrue"/>
</member>
<member name="M:Tensor.Tensor`1.countTrueAxis(System.Int32,Tensor.Tensor{System.Boolean})">
 <summary>Counts the elements being true along the specified axis.</summary>
 <param name="ax">The axis the count along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[true; false; true; false]
                              [false; true; true; false]]
 let b = Tensor.countTrueAxis 1 a // b = [2L; 2L]
 </code></example>
 <remarks>The number of elements that are true is accumulated along the specified axis.</remarks>
 <seealso cref="FillCountTrueAxis"/><seealso cref="countTrue"/>
</member>
<member name="M:Tensor.Tensor`1.countTrue(Tensor.Tensor{System.Boolean})">
 <summary>Counts the elements being true.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A scalar containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[true; false; true; false]
                              [false; true; true; false]]
 let b = Tensor.countTrue a // b = 4L
 </code></example>
 <remarks>The number of elements that are true is counted and returned as a scalar.</remarks>
 <seealso cref="countTrueTensor"/><seealso cref="countTrueAxis"/>    
</member>
<member name="M:Tensor.Tensor`1.copy(Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{Tensor.TensorOrder})">
 <summary>Returns a copy of the tensor.</summary>
 <param name="a">The tensor to copy.</param>
 <param name="order">The memory layout of the copy. (default: row-major)</param>
 <returns>A copy of the tensor.</returns>
 <remarks>    
 <para>A new tensor is created with the specified memory layout on the same device as the orignal tensor.</para>
 <para>The elements of the original tensor are copied into the new tensor.</para>
 </remarks>    
 <seealso cref="CopyFrom"/><seealso cref="transfer``1"/>
</member>
<member name="M:Tensor.Tensor`1.convert``1(Tensor.Tensor{``0})">
 <summary>Convert the elements of a tensor to the specifed type.</summary>
 <typeparam name="'C">The data type to convert from.</typeparam>
 <param name="a">The tensor to convert.</param>
 <returns>A tensor of the new data type.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [1; 2; 3] 
 let b = Tensor&lt;float>.convert a // b = [1.0; 2.0; 3.0]
 </code></example>       
 <remarks>    
 <para>The elements of the original tensor are copied into the new tensor and their type is converted
 during the copy.</para>
 <para>For tensors that contain data of non-primitive types and are stored on the host, 
 the <c>op_Explicit</c> or <c>op_Implicit</c> methods of the source or destination type are used to perform
 the conversion.</para>
 </remarks>    
 <seealso cref="FillConvert``1"/>
</member>
<member name="M:Tensor.Tensor`1.concat(System.Int32,System.Collections.Generic.IEnumerable{Tensor.Tensor{`0}})">
 <summary>Concatenates tensors along an axis.</summary>
 <param name="ax">The concatenation axis.</param>        
 <param name="ts">Sequence of tensors to concatenate.</param>    
 <returns>The concatenated tensor.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [4L; 28L]
 let b = HostTensor.zeros [4L; 15L]
 let c = HostTensor.zeros [4L; 10L]
 let d = Tensor.concat 1 [a; b; c] // d.Shape = [4L; 53L]
 </code></example>    
 <remarks>    
 <para>The contents of a the tensors are concatenated in the specifed dimension.</para>
 <para>The sizes of the tensors in all other dimensions must be equal.</para>
 </remarks>    
 <seealso cref="ofBlocks"/>
</member>
<member name="M:Tensor.Tensor`1.broadcastToSameInDims(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{`0}})">
 <summary>Broadcasts all specified tensors to have the same size in the specified dimensions.</summary>
 <param name="dims">A list of dimensions that should be broadcasted to have the same size.</param>
 <param name="xs">A list of tensors to operate on.</param>
 <returns>A list of the resulting tensors, all having the same size in the specified dimensions.</returns>
 <seealso cref="broadcastToSameInDims``2"/>
</member>
<member name="M:Tensor.Tensor`1.broadcastToSameInDims``3(System.Collections.Generic.IEnumerable{System.Int32},Tensor.Tensor{``0},Tensor.Tensor{``1},Tensor.Tensor{``2})">
 <summary>Broadcasts all specified tensors to have the same size in the specified dimensions.</summary>
 <param name="dims">A list of dimensions that should be broadcasted to have the same size.</param>
 <param name="a">The tensor to operate on.</param>
 <param name="b">The tensor to operate on.</param>    
 <param name="c">The tensor to operate on.</param>    
 <returns>A tuple of the resulting tensors, all having the same size in the specified dimensions.</returns>
 <seealso cref="broadcastToSameInDims``2"/>
</member>
<member name="M:Tensor.Tensor`1.broadcastToSameInDims``2(System.Collections.Generic.IEnumerable{System.Int32},Tensor.Tensor{``0},Tensor.Tensor{``1})">
 <summary>Broadcasts all specified tensors to have the same size in the specified dimensions.</summary>
 <param name="dims">A list of dimensions that should be broadcasted to have the same size.</param>
 <param name="a">The tensor to operate on.</param>
 <param name="b">The tensor to operate on.</param>    
 <returns>A tuple of the resulting tensors, all having the same size in the specified dimensions.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [1L; 7L; 1L]
 let b = HostTensor.zeros [3L; 4L; 5L]
 let pa, pb = Tensor.broadcastToSameInDims ([0; 2], a, b) // pa.Shape = [3L; 7L; 5L]; pb.Shape = [3L; 4L; 5L]
 </code></example>    
 <remarks>
 <para>The specified dimensions are broadcasted to match the size of non-size-one dimensions.</para>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <exception cref="System.InvalidOperationException">Raised when broadcasting to a common shape is impossible.</exception>
 <seealso cref="broadcastToSame``2"/><seealso cref="broadcastTo"/>
</member>
<member name="M:Tensor.Tensor`1.broadcastToSame(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{`0}})">
 <summary>Broadcasts all specified tensors to have the same shape.</summary>
 <param name="xs">A list of tensors to operate on.</param>    
 <returns>A list of the resulting tensors, all having the same shape.</returns>
 <seealso cref="broadcastToSame``2"/>
</member>
<member name="M:Tensor.Tensor`1.broadcastToSame``3(Tensor.Tensor{``0},Tensor.Tensor{``1},Tensor.Tensor{``2})">
 <summary>Broadcasts all specified tensors to have the same shape.</summary>
 <param name="a">The tensor to operate on.</param>
 <param name="b">The tensor to operate on.</param>    
 <param name="c">The tensor to operate on.</param>    
 <returns>A tuple of the resulting tensors, all having the same shape.</returns>
 <seealso cref="broadcastToSame``2"/>
</member>
<member name="M:Tensor.Tensor`1.broadcastToSame``2(Tensor.Tensor{``0},Tensor.Tensor{``1})">
 <summary>Broadcasts all specified tensors to have the same shape.</summary>
 <param name="a">The tensor to operate on.</param>
 <param name="b">The tensor to operate on.</param>    
 <returns>A tuple of the resulting tensors, all having the same shape.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [4L; 5L]
 let b = HostTensor.zeros [3L; 4L; 5L]
 let pa, pb = Tensor.broadcastToSame (a, b) // pa.Shape = [3L; 4L; 5L]; pb.Shape = [3L; 4L; 5L]
 </code></example>    
 <remarks>
 <para>First, size one dimensions are added from the left to each tensor until all of them have the same 
 dimensionality. Then, size one dimensions are broadcasted to match the size of non-size-one dimensions.</para>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <exception cref="System.InvalidOperationException">Raised when broadcasting to a common shape is impossible.</exception>
 <seealso cref="padToSame``2"/><seealso cref="broadcastToSameInDims``2"/><seealso cref="broadcastTo"/>
</member>
<member name="M:Tensor.Tensor`1.broadcastTo(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Tensor{`0})">
 <summary>Broadcasts the specified tensor to the specified shape.</summary>
 <param name="shp">The target shape.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>Tensor of shape <paramref name="shp"/>.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [1L; 7L; 1L]
 let pa = Tensor.broadcastTo [2L; 7L; 3L] a // pa.Shape = [2L; 7L; 3L]
 </code></example>    
 <remarks>
 <para>Size one dimensions are broadcasted to match the corresponding dimension of the target shape 
 <paramref name="shp"/>. Non-size-one dimensions must match the target shape.</para>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <exception cref="System.InvalidOperationException">Raised when broadcasting to the specified shape is impossible.</exception>
 <seealso cref="broadcastToSame``2"/>
</member>
<member name="M:Tensor.Tensor`1.broadcastDim(System.Int32,System.Int64,Tensor.Tensor{`0})">
 <summary>Broadcast a dimension to a specified size.</summary>
 <param name="dim">The size-one dimension to broadcast.</param>
 <param name="size">The size to broadcast to.</param>    
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [3L; 1L; 5L]
 let b = Tensor.broadCastDim 1 9L a // b.Shape = [3L; 9L; 5L]
 </code></example>    
 <remarks>
 <para>The broadcasted dimension must be of size one. The tensor is repeated <paramref name="size"/> times along
 the axis <paramref name="dim"/>.</para>
 <para>Broadcasting is usually performed automatically when the shapes allow for it. See broadcasting rules
 for details.</para>
 <para>The operation returns a view of the original tensor and shares its storage. Modifications done to the
 returned tensor will affect the original tensor. Also, modifying the orignal tensor will affect the view.</para>
 </remarks>
 <seealso cref="insertAxis"/>
</member>
<member name="M:Tensor.Tensor`1.atLeastND(System.Int32,Tensor.Tensor{`0})">
 <summary>Pads the tensor from the left with size-one dimensions until it has at least the specified number of
 dimensions.</summary>
 <param name="minDims">The minimum number of dimensions.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>A tensor with at least <paramref name="minDims"/> dimensions.</returns>
 <example><code language="fsharp">
 let a = HostTensor.zeros [2L; 3L]
 let b = Tensor.atLeastND 5 a // b.Shape = [1L; 1L; 1L; 2L; 3L]
 </code></example>    
 <remarks>    
 <para>Size-one dimensions are inserted at the front until the tensor has at least the specified number of 
 dimensions. If it already has the specified number of dimensions or more, it is returned unchanged.</para>
 <para>A view of the original tensor is returned and the storage is shared. Modifications done to the returned 
 tensor will affect the original tensor.</para>
 </remarks>    
 <seealso cref="padLeft"/><seealso cref="reshape"/>    
</member>
<member name="M:Tensor.Tensor`1.atLeast3D(Tensor.Tensor{`0})">
 <summary>Pads the tensor from the left with size-one dimensions until it has at least three dimensions.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>A tensor with at least three dimensions.</returns>
 <seealso cref="atLeastND"/>
</member>
<member name="M:Tensor.Tensor`1.atLeast2D(Tensor.Tensor{`0})">
 <summary>Pads the tensor from the left with size-one dimensions until it has at least two dimensions.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>A tensor with at least two dimensions.</returns>
 <seealso cref="atLeastND"/>
</member>
<member name="M:Tensor.Tensor`1.atLeast1D(Tensor.Tensor{`0})">
 <summary>Pads the tensor from the left with size-one dimensions until it has at least one dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>A tensor with at least one dimensions.</returns>
 <seealso cref="atLeastND"/>
</member>
<member name="M:Tensor.Tensor`1.argMinAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Finds the index of the minimum value along the specified axis.</summary>
 <param name="ax">The axis to calculate the minimum along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.argMinAxis 1 a // b = [0L; 0L]
 </code></example>
 <remarks>The index of the minimum is calculated along the specified axis. 
 An empty tensor gives <see cref="Tensor.NotFound"/>.</remarks>
 <seealso cref="FillArgMinAxis``1"/><seealso cref="argMin"/>
</member>
<member name="M:Tensor.Tensor`1.argMin(Tensor.Tensor{`0})">
 <summary>Finds the indicies of the minimum value of the tensor.</summary>
 <param name="a">The tensor containing the source values.</param>    
 <returns>The indices of the position of the minimum value.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.argMin 1 a // b = [0L; 0L]
 </code></example>
 <remarks>The minimum value within the specified tensor is found and its indicies are returned. 
 The function fails for an empty tensor.</remarks>
 <seealso cref="argMinAxis"/>
</member>
<member name="M:Tensor.Tensor`1.argMaxAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Finds the index of the maximum value along the specified axis.</summary>
 <param name="ax">The axis to calculate the maximum along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.argMaxAxis 1 a // b = [3L; 3L]
 </code></example>
 <remarks>The index of the maximum is calculated along the specified axis. 
 An empty tensor gives <see cref="Tensor.NotFound"/>.</remarks>
 <seealso cref="FillArgMaxAxis``1"/><seealso cref="argMax"/>
</member>
<member name="M:Tensor.Tensor`1.argMax(Tensor.Tensor{`0})">
 <summary>Finds the indicies of the maximum value of the tensor.</summary>
 <param name="a">The tensor containing the source values.</param>    
 <returns>The indices of the position of the maximum value.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[1.0; 2.0; 3.0; 4.0]
                              [5.0; 6.0; 7.0; 8.0]]
 let b = Tensor.argMax a // b = [1L; 3L]
 </code></example>
 <remarks>The maximum value within the specified tensor is found and its indicies are returned. 
 The function fails for an empty tensor.</remarks>
 <seealso cref="argMaxAxis"/>
</member>
<member name="M:Tensor.Tensor`1.arange(Tensor.Backend.ITensorDevice,`0,`0,`0)">
 <summary>Creates a new vector filled with equaly spaced values using a specifed increment.</summary>
 <param name="dev">The device to create the tensor on.</param>
 <param name="start">The starting value.</param>
 <param name="incr">The increment between successive element.</param>   
 <param name="stop">The end value, which is not included.</param>
 <returns>The new tensor.</returns>
 <example><code language="fsharp">
 let a = Tensor.arange HostTensor.Dev 1.0 0.1 2.0
 // a = [1.0; 1.1; 1.2; 1.3; 1.4; 1.5; 1.6; 1.7; 1.8; 1.9]
 </code></example>         
 <remarks>
 <para>A new vector with <c>floor ((stop - start) / incr)</c> elements is created on the specified device.</para>
 <para>The vector is filled with <c>[start; start+1*incr; start+2*incr; ...]</c>.</para>
 <para>If stop is smaller or equal to start, an empty vector is returned.</para>
 </remarks>
 <seealso cref="counting"/><seealso cref="linspace``1"/>
</member>
<member name="M:Tensor.Tensor`1.anyTensor(Tensor.Tensor{System.Boolean})">
 <summary>Checks if any element of the tensor is true returning the result as a tensor.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="any"/>
</member>
<member name="M:Tensor.Tensor`1.anyAxis(System.Int32,Tensor.Tensor{System.Boolean})">
 <summary>Checks if any element along the specified axis is true.</summary>
 <param name="ax">The axis to check along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[true; true; true]
                              [false; true; true]]
 let b = Tensor.anyAxis 1 a // b = [true; true]
 </code></example>
 <remarks>
 <para>It is checked whether any element along the specified axis is true.
 If so, true is returned; otherwise false is returned.</para>
 <para>If the tensor is empty false is returned.</para>
 </remarks>
 <seealso cref="FillAnyAxis"/><seealso cref="any"/>
</member>
<member name="M:Tensor.Tensor`1.any(Tensor.Tensor{System.Boolean})">
 <summary>Checks if any elements of the tensor are true.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A scalar containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[true; true; true]
                              [false; true; true]]
 let b = Tensor.any a // b = true
 </code></example>
 <remarks>
 <para>It is checked whether any element of the tensor is true.
 If so, true is returned; otherwise false is returned.</para>
 <para>If the tensor is empty false is returned.</para>
 </remarks>
 <seealso cref="anyTensor"/><seealso cref="anyAxis"/>
</member>
<member name="M:Tensor.Tensor`1.almostEqual(Tensor.Tensor{`0},Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{`0},Microsoft.FSharp.Core.FSharpOption{`0})">
 <summary>Checks if two tensors have the same (within machine precision) values in all elements.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <param name="absTol">The absolute tolerance. (default 1e-8)</param>
 <param name="relTol">The relative tolerance. (default 1e-5)</param>
 <returns>true if two tensors have same (within specified precision) values in all elements, otherwise false.</returns>
 <remarks>
 <para>Test each element of tensor <paramref name="a"/> for being almost equal to the corresponding element 
 of tensor <paramref name="b"/>. For integer data types the check is exact.</para>
 <para>If tensors have different shape, then false is returned.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same storage and type.</para>
 </remarks>
 <seealso crf="isClose``1"/>
</member>
<member name="M:Tensor.Tensor`1.allTensor(Tensor.Tensor{System.Boolean})">
 <summary>Checks if all elements of the tensor are true returning the result as a tensor.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="all"/>
</member>
<member name="M:Tensor.Tensor`1.allIdx(Tensor.Tensor{`0})">
 <summary>Gets a sequence of all indices to enumerate all elements within the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Sequence of indicies.</returns>
 <remarks>The sequence sequentially enumerates the indices of all elements of the tensor.</remarks>
 <seealso cref="allIdxOfDim"/><seealso cref="allElems"/>
</member>
<member name="M:Tensor.Tensor`1.allFinite(Tensor.Tensor{`0})">
 <summary>Checks that all elements of the tensor are finite.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>true if all elements are finite, otherwise false.</returns>
 <remarks>
 <para>Checks each element of the specified tensor for finity (not -Inf, Inf or NaN).</para>
 </remarks>
 <seealso crf="isFinite``1"/>
</member>
<member name="M:Tensor.Tensor`1.allElems(Tensor.Tensor{`0})">
 <summary>Gets a sequence of all all elements within the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Sequence of elements.</returns>
 <remarks>The sequence sequentially enumerates all elements of the tensor.</remarks>
 <seealso cref="allIdx"/>
</member>
<member name="M:Tensor.Tensor`1.allAxis(System.Int32,Tensor.Tensor{System.Boolean})">
 <summary>Checks if all elements along the specified axis are true.</summary>
 <param name="ax">The axis to check along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[true; true; true]
                              [false; true; true]]
 let b = Tensor.allAxis 1 a // b = [true; false]
 </code></example>
 <remarks>
 <para>It is checked whether all elements along the specified axis are true.
 If so, true is returned; otherwise false is returned.</para>
 <para>If the tensor is empty true is returned.</para>
 </remarks>
 <seealso cref="FillAllAxis"/><seealso cref="all"/>
</member>
<member name="M:Tensor.Tensor`1.all(Tensor.Tensor{System.Boolean})">
 <summary>Checks if all elements of the tensor are true.</summary>
 <param name="src">The tensor containing the source values.</param>    
 <returns>A scalar containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList2D [[true; true; true]
                              [false; true; true]]
 let b = Tensor.all a // b = false
 </code></example>
 <remarks>
 <para>It is checked whether all elements of the tensor are true.
 If so, true is returned; otherwise false is returned.</para>
 <para>If the tensor is empty true is returned.</para>
 </remarks>
 <seealso cref="allTensor"/><seealso cref="allAxis"/>
</member>
<member name="M:Tensor.Tensor`1.Truncate(Tensor.Tensor{`0})">
 <summary>Element-wise truncation (rounding towards zero).</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-3.0; -2.7; 2.7; 3.0]
 let b = truncate a // b = [-3.0; -2.0; 2.0; 3.0]
 </code></example>
 <remarks>Computes the truncation (rounding towards zero) of each element of the specified tensor and returns
 them as a new tensor.
 Do not call this function directly; instead use the F# <c>truncate</c> function.</remarks>
 <seealso cref="FillTruncate"/>
</member>
<member name="M:Tensor.Tensor`1.TransferFrom(Tensor.Tensor{`0})">
 <summary>Transfers the specified tensor located on another device into this tensor.</summary>
 <param name="src">The tensor to transfer from.</param>
 <remarks>    
 <para>The elements of the original tensor are copied into the new tensor.</para>
 <para>Both tensors must have same shape and type.</para>
 <para>If both tensors are located on the same device, a copy is performed.</para>
 </remarks>    
 <see cref="transfer``1"/>
</member>
<member name="M:Tensor.Tensor`1.Transfer(Tensor.Backend.ITensorDevice)">
<summary>
 Transfers this tensor to the specifed device.
</summary>
</member>
<member name="M:Tensor.Tensor`1.ToString">
 <summary>String representation of the tensor limited to 10 elements per dimension.</summary>
 <returns>A (shortened) string representation of this tensor</returns>
 <seealso cref="ToString(System.Int64)"/><seealso cref="Pretty"/><seealso cref="Full"/>   
</member>
<member name="M:Tensor.Tensor`1.ToString(System.Int64)">
 <summary>String representation of the tensor limited to a specific number of elements per dimension.</summary>
 <param name="maxElems">Maximum number of element per dimension to include in string representation.</param>
 <returns>A (shortened) string representation of this tensor</returns>
 <seealso cref="Full"/><seealso cref="Pretty"/>
</member>
<member name="M:Tensor.Tensor`1.Tanh(Tensor.Tensor{`0})">
 <summary>Element-wise hyperbolic tangent.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-1.57079; 0.0; 1.57079]
 let b = tanh a // b = [-0.91715; 0.0; 0.91715]
 </code></example>
 <remarks>Computes the hyperbolic tangent of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>tanh</c> function.</remarks>
 <seealso cref="FillTanh"/>
</member>
<member name="M:Tensor.Tensor`1.Tan(Tensor.Tensor{`0})">
 <summary>Element-wise tangent.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-1.57079; 0.0; 1.57079]
 let b = tan a // b = [-158057.9134; 0.0; 158057.9134]
 </code></example>
 <remarks>Computes the tangent of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>tan</c> function.</remarks>
 <seealso cref="FillTan"/><seealso cref="Atan"/>
</member>
<member name="M:Tensor.Tensor`1.Sqrt(Tensor.Tensor{`0})">
 <summary>Element-wise square root.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [1.0; 4.0; 16.0]
 let b = sqrt a // b = [1.0; 2.0; 4.0]
 </code></example>
 <remarks>Computes the square root of each element of the specified tensor and returns them as a new tensor.
 Do not call this function directly; instead use the F# <c>sqrt</c> function.</remarks>
 <seealso cref="FillSqrt"/>
</member>
<member name="M:Tensor.Tensor`1.Sinh(Tensor.Tensor{`0})">
 <summary>Element-wise hyperbolic sine.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-1.57079; 0.0; 1.57079]
 let b = sinh a // b = [-2.30128; 0.0; 2.30128]
 </code></example>
 <remarks>Computes the hyperbolic sine of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>sinh</c> function.</remarks>
 <seealso cref="FillSinh"/>
</member>
<member name="M:Tensor.Tensor`1.Sin(Tensor.Tensor{`0})">
 <summary>Element-wise sine.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-1.57079; 0.0; 1.57079]
 let b = sin a // b = [-1.0; 0.0; 1.0]
 </code></example>
 <remarks>Computes the sine of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>sin</c> function.</remarks>
 <seealso cref="FillSin"/><seealso cref="Asin"/>
</member>
<member name="M:Tensor.Tensor`1.Sgn(Tensor.Tensor{`0})">
 <summary>Element-wise sign.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-2; -1; 0; 2]
 let b = sgn a // b = [-1; -1; 0; 1]
 </code></example>
 <remarks>Computes the sign of each element of the specified tensor and returns them as a new tensor.
 The type of the returned tensor matches the type of the argument tensor.
 Do not call this function directly; instead use the F# <c>sgn</c> function.</remarks>
 <seealso cref="FillSgn"/>
</member>
<member name="M:Tensor.Tensor`1.SVDWithoutUV(Tensor.Tensor{`0})">
 <summary>Computes the (batched) singular values of the specified matrix.</summary>
 <param name="a">The input matrix or tensor to this operation.</param>
 <returns>A vector consisting of the singular values.</returns>
 <seealso cref="SVD"/>
</member>
<member name="M:Tensor.Tensor`1.SVDSizes(Tensor.Backend.ITensorFrontend{`0})">
<summary>
 Computes the sizes of an SVD decomposition.
</summary>
</member>
<member name="M:Tensor.Tensor`1.SVD(Tensor.Tensor{`0})">
 <summary>Computes the (batched) singular value decomposition (SVD) of the specified matrix.</summary>
 <param name="a">The input matrix or tensor to this operation.</param>
 <returns>A tuple consisting of <c>(U, S, V)</c> where <c>S</c> is a vector consisting of the singular values and
 <c>U</c>, <c>V</c> are the transformation matrices.</returns>
 <remarks>
 <para>The singular value decomposition of matrix <paramref name="a"/> is computed.
 It is defined by the property that <c>a = U .* Tensor.diagMat(S) .* V.T</c>.</para>
 <para>If <paramref name="a"/> is a tensor, the operation is batched over the matrices consisting
 of the last two dimensions.</para>
 </remarks>    
 <seealso cref="FillSVD"/><seealso cref="SVDWithoutUV"/>
</member>
<member name="M:Tensor.Tensor`1.Round(Tensor.Tensor{`0})">
 <summary>Element-wise rounding.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-3.0; -2.7; 2.7; 3.0]
 let b = round a // b = [-3.0; -3.0; 3.0; 3.0]
 </code></example>
 <remarks>Computes the rounding of each element of the specified tensor and returns them as a new tensor.
 Do not call this function directly; instead use the F# <c>round</c> function.</remarks>
 <seealso cref="FillRound"/>
</member>
<member name="M:Tensor.Tensor`1.Relayout(Tensor.Backend.TensorLayout)">
<summary>
 a tensor with the same storage but new layout
</summary>
</member>
<member name="M:Tensor.Tensor`1.Range(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng})">
<summary>
 a view of this tensor over the given range 
</summary>
</member>
<member name="M:Tensor.Tensor`1.Pow(`0,Tensor.Tensor{`0})">
 <summary>Element-wise exponentiation with scalar.</summary>
 <param name="a">The scalar on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="Pow"/>
</member>
<member name="M:Tensor.Tensor`1.Pow(Tensor.Tensor{`0},`0)">
 <summary>Element-wise exponentiation with scalar.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The scalar on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <seealso cref="Pow"/>
</member>
<member name="M:Tensor.Tensor`1.Pow(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Element-wise exponentiation.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [5.0; 6.0; 7.0]
 let b = HostTensor.ofList [2.0; 3.0; 4.0]
 let c = a ** b // c = [25.0; 216.0; 2401.0]
 </code></example>
 <remarks>
 <para>Computes the exponentiation of each element of tensor <paramref name="a"/> to the power given by the
 corresponding element of tensor <paramref name="b"/> and returns the results as a new tensor.</para>
 <para>Do not call this function directly; instead use the F# <c>**</c> operator.</para>
 <para>The tensors <paramref name="a"/> and <paramref name="b"/> must have the same type and storage.
 Broadcasting rules apply if <paramref name="a"/> and <paramref name="b"/> have different shapes.</para>
 </remarks>
 <seealso cref="FillPower"/>
</member>
<member name="M:Tensor.Tensor`1.NewOfType(Microsoft.FSharp.Collections.FSharpList{System.Int64},System.Type,Tensor.Backend.ITensorDevice,Microsoft.FSharp.Core.FSharpOption{Tensor.TensorOrder})">
 <summary>Type-neutral function for creating a new, uninitialized tensor with a new storage.</summary>
 <param name="shape">The shape of the tensor to create.</param>
 <param name="dataType">The data type of the tensor to create.</param>
 <param name="dev">The device to store the data of the tensor on.</param>
 <param name="order">The memory layout to use for the new tensor.</param>
 <returns>The new, uninitialized tensor.</returns>
 <remarks>
 <para>The contents of the new tensor are undefined.</para>
 <para>Use this function only if you require a type-neutral function.
 The recommended way is to use <see cref="zeros"/> to create a typed tensor.</para>
 </remarks>
 <seealso cref="#ctor"/>
</member>
<member name="M:Tensor.Tensor`1.MaskedSet(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{System.Boolean}},Tensor.Tensor{`0})">
<summary>
 Set all elements of this tensor where mask is true to the specfied values.
</summary>
</member>
<member name="M:Tensor.Tensor`1.MaskedGet(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{System.Boolean}})">
<summary>
 Collect all elements of this tensor where mask is true.
</summary>
</member>
<member name="M:Tensor.Tensor`1.MaskShapes(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{Tensor.Tensor{System.Boolean}}},Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 Computes the shape of the targets and sources of a mask operation. 
</summary>
</member>
<member name="M:Tensor.Tensor`1.MaskOptions(Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{System.Boolean}})">
<summary>
 Converts a list of masks (which may be null) to a list of mask options.
</summary>
</member>
<member name="M:Tensor.Tensor`1.MaskAsBoolTensor(Tensor.ITensor)">
<summary>
 Cast ITensor to Tensor&lt;bool&gt; for use as mask.
</summary>
</member>
<member name="M:Tensor.Tensor`1.Log10(Tensor.Tensor{`0})">
 <summary>Element-wise common logarithm.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [1.0; 10.0; 100.0]
 let b = log10 a // b = [0.0; 1.0; 2.0]
 </code></example>
 <remarks>Computes the common logarithm (to base 10) of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>log10</c> function.</remarks>
 <seealso cref="FillLog10"/><seealso cref="Log"/>
</member>
<member name="M:Tensor.Tensor`1.Log(Tensor.Tensor{`0})">
 <summary>Element-wise natural logarithm.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [1.0; 2.71828; 4.0]
 let b = log a // b = [0.0; 1.0; 1.38529]
 </code></example>
 <remarks>Computes the natural logarithm of each element of the specified tensor and returns them as a new tensor.
 Do not call this function directly; instead use the F# <c>log</c> function.</remarks>
 <seealso cref="FillLog"/><seealso cref="Log10"/><seealso cref="Exp"/>
</member>
<member name="M:Tensor.Tensor`1.GetHashCode">
 <summary>Calculates the hash code of the tensor.</summary>
 <returns>The hash code.</returns>
 <remarks>
 <para>The hash code is calculated from the storage and layout of the tensor.
 If two tensors are equal, they will have the same hash code.</para>
 </remarks>
 <seealso cref="Equals"/>
</member>
<member name="M:Tensor.Tensor`1.Floor(Tensor.Tensor{`0})">
 <summary>Element-wise floor (round towards negative infinity).</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-3.0; -2.7; 2.7; 3.0]
 let b = floor a // b = [-3.0; -3.0; 2.0; 3.0]
 </code></example>
 <remarks>Computes the floor (round towards negative infinity) of each element of the specified tensor and 
 returns them as a new tensor.
 Do not call this function directly; instead use the F# <c>floor</c> function.</remarks>
 <seealso cref="FillFloor"/>
</member>
<member name="M:Tensor.Tensor`1.FillXor(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean})">
 <summary>Fills this tensor with the element-wise logical xor of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_HatHatHatHat"/>
</member>
<member name="M:Tensor.Tensor`1.FillUnaryPlus(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise prefix plus of the argument.</summary>
 <param name="a">The tensor to operate on.</param>
 <seealso cref="op_UnaryPlus"/>
</member>
<member name="M:Tensor.Tensor`1.FillUnaryMinus(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise negation of the argument.</summary>
 <param name="a">The tensor to operate on.</param>
 <seealso cref="op_UnaryNegation"/>
</member>
<member name="M:Tensor.Tensor`1.FillTruncate(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise truncation (rounding towards zero) of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Truncate"/>
</member>
<member name="M:Tensor.Tensor`1.FillTanh(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise hyperbolic tangent of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Tanh"/>
</member>
<member name="M:Tensor.Tensor`1.FillTan(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise tangent of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Tan"/>
</member>
<member name="M:Tensor.Tensor`1.FillSymmetricEigenDecomposition(Tensor.MatrixPart,Tensor.Tensor{`0},Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Computes the (real) eigendecomposition of a symmetric matrix and writes it into the specified 
 target tensors.</summary>
 <param name="part">Specifies which part of the matrix should be used.</param>
 <param name="trgtEigVals">The target vector that will receive the eigenvalues.</param>
 <param name="trgtEigVecs">The target matrix that will receive the eigenvectors.</param>    
 <param name="a">The input matrix to this operation.</param>
 <seealso cref="symmetricEigenDecomposition"/>
</member>
<member name="M:Tensor.Tensor`1.FillSumAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Sums the elements over the specified axis and writes the result into this tensor.</summary>
 <param name="ax">The axis to sum along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="sumAxis"/>        
</member>
<member name="M:Tensor.Tensor`1.FillSubtract(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise substraction of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_Subtraction"/>
</member>
<member name="M:Tensor.Tensor`1.FillSqrt(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise square root of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Sqrt"/>
</member>
<member name="M:Tensor.Tensor`1.FillSinh(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise hyperbolic sine of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Sinh"/>
</member>
<member name="M:Tensor.Tensor`1.FillSin(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise sine of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Sin"/>
</member>
<member name="M:Tensor.Tensor`1.FillSgn(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise sign of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Sgn"/>
</member>
<member name="M:Tensor.Tensor`1.FillScatter(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{Tensor.Tensor{System.Int64}}},Tensor.Tensor{`0})">
 <summary>Disperses elements from a source tensor to this tensor according to the specified indices.</summary>
 <param name="indices">A list of tensors, one per dimension of this tensor, containing the target indicies
 for each element of <paramref name="src"/>.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="scatter"/>
</member>
<member name="M:Tensor.Tensor`1.FillSVD(Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{System.Tuple{Tensor.Tensor{`0},Tensor.Tensor{`0}}})">
 <summary>Fills this tensor with the (batched) singular values of the specified matrix.</summary>
 <param name="a">The input matrix or tensor to this operation.</param>
 <param name="trgtUV">The optional target tensors for the transformation matrices.</param>
 <remarks>
 <para>The singular values are stored in this vector.</para>
 </remarks>
 <seealso cref="SVD"/><seealso cref="SVDWithoutUV"/>
</member>
<member name="M:Tensor.Tensor`1.FillRound(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise rounding of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Round"/>
</member>
<member name="M:Tensor.Tensor`1.FillPseudoInvert(Tensor.Tensor{`0},Microsoft.FSharp.Core.FSharpOption{`0})">
 <summary>Fills this tensor with the (batched) Moore-Penrose pseudo-inverse of the specified matrix.</summary>
 <param name="a">The input matrix or tensor to this operation.</param>
 <param name="rCond">The cut-off value for the singular values. (default: 1e-15)</param>
 <seealso cref="pseudoInvert"/>
</member>
<member name="M:Tensor.Tensor`1.FillProductAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Calculates the product of the elements over the specified axis and writes the result into this tensor.</summary>
 <param name="ax">The axis to calculate the product along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="productAxis"/>     
</member>
<member name="M:Tensor.Tensor`1.FillPower(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise exponentiation.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="Pow"/>
</member>
<member name="M:Tensor.Tensor`1.FillOr(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean})">
 <summary>Fills this tensor with the element-wise logical or of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_BarBarBarBar"/>
</member>
<member name="M:Tensor.Tensor`1.FillNotEqual``1(Tensor.Tensor{``0},Tensor.Tensor{``0})">
 <summary>Fills this tensor with the element-wise not-equality test or of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_LessLessGreaterGreater"/>
</member>
<member name="M:Tensor.Tensor`1.FillNegate(Tensor.Tensor{System.Boolean})">
 <summary>Fills this tensor with the element-wise logical negation of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="op_TwiddleTwiddleTwiddleTwiddle"/>
</member>
<member name="M:Tensor.Tensor`1.FillMultiply(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise multiplication of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_Multiply"/>
</member>
<member name="M:Tensor.Tensor`1.FillModulo(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise remainder of the division of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_Modulus"/>
</member>
<member name="M:Tensor.Tensor`1.FillMinElemwise(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise minimum of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="minElemwise"/>
</member>
<member name="M:Tensor.Tensor`1.FillMinAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Calculates the minimum value of the elements over the specified axis and writes the result into this tensor.</summary>
 <param name="ax">The axis to calculate the minimum along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="minAxis"/>     
</member>
<member name="M:Tensor.Tensor`1.FillMaxElemwise(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise maximum of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="maxElemwise"/>
</member>
<member name="M:Tensor.Tensor`1.FillMaxAxis(System.Int32,Tensor.Tensor{`0})">
 <summary>Calculates the maximum value of the elements over the specified axis and writes the result into this tensor.</summary>
 <param name="ax">The axis to calculate the maximum along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="maxAxis"/>   
</member>
<member name="M:Tensor.Tensor`1.FillLog10(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise common logarithm of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Log10"/>
</member>
<member name="M:Tensor.Tensor`1.FillLog(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise natural logarithm of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Log"/>
</member>
<member name="M:Tensor.Tensor`1.FillLessOrEqual``1(Tensor.Tensor{``0},Tensor.Tensor{``0})">
 <summary>Fills this tensor with the element-wise less-than-or-equal test of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_LessLessEqualsEquals"/>
</member>
<member name="M:Tensor.Tensor`1.FillLess``1(Tensor.Tensor{``0},Tensor.Tensor{``0})">
 <summary>Fills this tensor with the element-wise less-than test of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_LessLessLessLess"/>
</member>
<member name="M:Tensor.Tensor`1.FillIsFinite``1(Tensor.Tensor{``0})">
 <summary>Fills this tensor with the element-wise finity check (not -Inf, Inf or NaN) of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="isFinite"/>
</member>
<member name="M:Tensor.Tensor`1.FillInvert(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the (batch) inverse of a matrix.</summary>
 <param name="a">The input to this operation.</param>
 <seealso cref="invert"/>        
</member>
<member name="M:Tensor.Tensor`1.FillIncrementing(`0,`0)">
 <summary>Fills this vector with an equispaced sequence of elements.</summary>
 <param name="start">The starting value.</param>
 <param name="incr">The increment between successive elements.</param>    
 <remarks>
 <para>This tensor must be one dimensional.</para>
 </remarks>
 <seealso cref="arange``3"/>
</member>
<member name="M:Tensor.Tensor`1.FillIfThenElse(Tensor.Tensor{System.Boolean},Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Fills this tensor with an element-wise choice between two sources depending on a condition.</summary>
 <param name="cond">The condition tensor.</param>
 <param name="ifTrue">The tensor containing the values to use for when an element of the condition is true.</param>
 <param name="ifFalse">The tensor containing the values to use for when an element of the condition is false.</param>    
 <seealso cref="ifThenElse"/>
</member>
<member name="M:Tensor.Tensor`1.FillGreaterOrEqual``1(Tensor.Tensor{``0},Tensor.Tensor{``0})">
 <summary>Fills this tensor with the element-wise greater-than-or-equal test of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_GreaterGreaterEqualsEquals"/>
</member>
<member name="M:Tensor.Tensor`1.FillGreater``1(Tensor.Tensor{``0},Tensor.Tensor{``0})">
 <summary>Fills this tensor with the element-wise greater-than test of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_GreaterGreaterGreaterGreater"/>
</member>
<member name="M:Tensor.Tensor`1.FillGather(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpOption{Tensor.Tensor{System.Int64}}},Tensor.Tensor{`0})">
 <summary>Selects elements from a tensor according to specified indices.</summary>
 <param name="indices">A list of tensors, one per dimension of <paramref name="src"/>, containing the indicies
 to pick from <paramref name="src"/> for each output element.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="gather"/>
</member>
<member name="M:Tensor.Tensor`1.FillFrom(Tensor.Tensor{`0})">
 <summary>Fills this tensor with a copy of the specified tensor.</summary>
 <param name="src">The tensor to copy from.</param>
 <remarks>
 <para>The source tensor is broadcasted to the size of this tensor.</para>
 <para>The source tensor must be stored on the same device as this tensor.</para>
 </remarks>
 <seealso cref="CopyFrom"/>
</member>
<member name="M:Tensor.Tensor`1.FillFloor(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise floor (round towards negative infinity) of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Floor"/>
</member>
<member name="M:Tensor.Tensor`1.FillFindAxis``1(``0,System.Int32,Tensor.Tensor{``0})">
 <summary>Finds the first occurence of the specfied value along the specified axis and write its index into this tensor.</summary>
 <param name="value">The value to find.</param>
 <param name="ax">The axis to find the value along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="findAxis"/>
</member>
<member name="M:Tensor.Tensor`1.FillExp(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise exponential function of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Exp"/>
</member>
<member name="M:Tensor.Tensor`1.FillEqual``1(Tensor.Tensor{``0},Tensor.Tensor{``0})">
 <summary>Fills this tensor with the element-wise equality test of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_EqualsEqualsEqualsEquals"/>
</member>
<member name="M:Tensor.Tensor`1.FillDot(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Fill this tensor with the (batched) matrix product, matrix-vector product or scalar product of the 
 arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_DotMultiply"/>    
</member>
<member name="M:Tensor.Tensor`1.FillDivide(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise division of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_Division"/>
</member>
<member name="M:Tensor.Tensor`1.FillCountTrueAxis(System.Int32,Tensor.Tensor{System.Boolean})">
 <summary>Counts the elements being true along the specified axis and writes the result into this tensor.</summary>
 <param name="ax">The axis the count along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="countTrueAxis"/>        
</member>
<member name="M:Tensor.Tensor`1.FillCosh(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise hyperbolic cosine of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Cosh"/>
</member>
<member name="M:Tensor.Tensor`1.FillCos(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise cosine of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Cos"/>
</member>
<member name="M:Tensor.Tensor`1.FillConvert``1(Tensor.Tensor{``0})">
 <summary>Copies elements from a tensor of different data type into this tensor and converts their type.</summary>
 <typeparam name="'C">The data type to convert from.</typeparam>
 <param name="a">The tensor to copy from.</param>    
 <seealso cref="convert``1"/>
</member>
<member name="M:Tensor.Tensor`1.FillConst(`0)">
 <summary>Fills this tensor with the specified constant value.</summary>
 <param name="value">The value to use.</param>
 <seealso cref="filled"/>
</member>
<member name="M:Tensor.Tensor`1.FillCeiling(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise ceiling (round towards positive infinity) of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Ceiling"/>
</member>
<member name="M:Tensor.Tensor`1.FillAtan(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise arctanget (inverse tangent) of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Atan"/>
</member>
<member name="M:Tensor.Tensor`1.FillAsin(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise arcsine (inverse sine) of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Asin"/>
</member>
<member name="M:Tensor.Tensor`1.FillArgMinAxis``1(System.Int32,Tensor.Tensor{``0})">
 <summary>Finds the index of the minimum value along the specified axis and writes it into this tensor.</summary>
 <param name="ax">The axis to calculate the minimum along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="argMinAxis"/>
</member>
<member name="M:Tensor.Tensor`1.FillArgMaxAxis``1(System.Int32,Tensor.Tensor{``0})">
 <summary>Finds the index of the maximum value along the specified axis and writes it into this tensor.</summary>
 <param name="ax">The axis to calculate the maximum along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="argMaxAxis"/>
</member>
<member name="M:Tensor.Tensor`1.FillAnyAxis(System.Int32,Tensor.Tensor{System.Boolean})">
 <summary>Checks if any element along the specified axis is true using this tensor as target.</summary>
 <param name="ax">The axis to check along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="anyAxis"/>
</member>
<member name="M:Tensor.Tensor`1.FillAnd(Tensor.Tensor{System.Boolean},Tensor.Tensor{System.Boolean})">
 <summary>Fills this tensor with the element-wise logical and of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_AmpAmpAmpAmp"/>
</member>
<member name="M:Tensor.Tensor`1.FillAllAxis(System.Int32,Tensor.Tensor{System.Boolean})">
 <summary>Checks if all elements along the specified axis are true using this tensor as target.</summary>
 <param name="ax">The axis to check along.</param>
 <param name="src">The tensor containing the source values.</param>    
 <seealso cref="allAxis"/>
</member>
<member name="M:Tensor.Tensor`1.FillAdd(Tensor.Tensor{`0},Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise addition of the arguments.</summary>
 <param name="a">The tensor on the left side of this binary operation.</param>
 <param name="b">The tensor on the right side of this binary operation.</param>
 <seealso cref="op_Addition"/>
</member>
<member name="M:Tensor.Tensor`1.FillAcos(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise arccosine (inverse cosine) of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Acos"/>
</member>
<member name="M:Tensor.Tensor`1.FillAbs(Tensor.Tensor{`0})">
 <summary>Fills this tensor with the element-wise absolute value of the argument.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <seealso cref="Abs"/>
</member>
<member name="M:Tensor.Tensor`1.Exp(Tensor.Tensor{`0})">
 <summary>Element-wise exponential function.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-1.0; 0.0; 1.0; 10.0]
 let b = exp a // b = [0.36787; 1.0; 2.71828; 22026.4657]
 </code></example>
 <remarks>Computes the exponential function of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>exp</c> function.</remarks>
 <seealso cref="FillExp"/><seealso cref="Log"/>
</member>
<member name="M:Tensor.Tensor`1.Equals(System.Object)">
 <summary>Tests for equality to another object.</summary>
 <param name="other">The other object.</param>
 <returns>true if the objects are equal. Otherwise false.</returns>
 <remarks>
 <para>Two tensors are equal if they have the same storage and same layout.
 In this case, changing one tensor will have the exact same effect on the other tensor.</para>
 <para>Two tensors can overlap, i.e. one can partially or fully affect the other, without being equal.</para>
 <para>The elements of a tensor do not affect equality, i.e. two tensors can contain exactly the same values 
 without being equal.</para>
 </remarks>
 <seealso cref="op_EqualsEqualsEqualsEquals"/><seealso cref="almostEqual"/>
</member>
<member name="M:Tensor.Tensor`1.Cosh(Tensor.Tensor{`0})">
 <summary>Element-wise hyperbolic cosine.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-1.57079; 0.0; 1.57079]
 let b = cosh a // b = [2.50916; 1.0; 2.50916]
 </code></example>
 <remarks>Computes the hyperbolic cosine of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>cosh</c> function.</remarks>
 <seealso cref="FillCosh"/>
</member>
<member name="M:Tensor.Tensor`1.Cos(Tensor.Tensor{`0})">
 <summary>Element-wise cosine.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-1.57079; 0.0; 1.57079]
 let b = cos a // b = [0.0; 1.0; 0.0]
 </code></example>
 <remarks>Computes the cosine of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>cos</c> function.</remarks>
 <seealso cref="FillCos"/><seealso cref="Acos"/>
</member>
<member name="M:Tensor.Tensor`1.CopyFrom(Tensor.Tensor{`0})">
 <summary>Fills this tensor with a copy of the specified tensor.</summary>
 <param name="src">The tensor to copy from.</param>
 <remarks>
 <para>The source tensor must have the same shape and be stored on the same device as this tensor.</para>
 </remarks>
 <seealso cref="copy"/><seealso cref="FillFrom"/>
</member>
<member name="M:Tensor.Tensor`1.Copy(Microsoft.FSharp.Core.FSharpOption{Tensor.TensorOrder})">
<summary>
 Returns a copy of the tensor.
</summary>
</member>
<member name="M:Tensor.Tensor`1.CheckScalar">
<summary>
 Checks that this Tensor is a scalar tensor.
</summary>
</member>
<member name="M:Tensor.Tensor`1.CheckAxis(System.Int32)">
 <summary>Checks the the specified axis is valid for this tensor.</summary>   
 <param name="ax">The axis number to check.</param>
 <remarks>If the axis is valid, this function does nothing.</remarks>
 <exception cref="System.IndexOutOfRangeException">Raised when the axis is invalid.</exception>
</member>
<member name="M:Tensor.Tensor`1.Ceiling(Tensor.Tensor{`0})">
 <summary>Element-wise ceiling (round towards positive infinity).</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-3.0; -2.7; 2.7; 3.0]
 let b = ceil a // b = [-3.0; -2.0; 3.0; 3.0]
 </code></example>
 <remarks>Computes the ceiling (round towards positive infinity) of each element of the specified tensor and 
 returns them as a new tensor.
 Do not call this function directly; instead use the F# <c>ceil</c> function.</remarks>
 <seealso cref="FillCeiling"/>
</member>
<member name="M:Tensor.Tensor`1.Atan(Tensor.Tensor{`0})">
 <summary>Element-wise arctanget (inverse tangent).</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-1.0; 0.0; 1.0]
 let b = atan a // b = [-0.78539; 0.0; 0.78539]
 </code></example>
 <remarks>Computes the arctanget (inverse tangent) of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>atan</c> function.</remarks>
 <seealso cref="FillAcos"/><seealso cref="Tan"/>
</member>
<member name="M:Tensor.Tensor`1.Asin(Tensor.Tensor{`0})">
 <summary>Element-wise arcsine (inverse sine).</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-1.0; 0.0; 1.0]
 let b = asin a // b = [-1.57079; 0.0; 1.57079]
 </code></example>
 <remarks>Computes the arcsine (inverse sine) of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>asin</c> function.</remarks>
 <seealso cref="FillAsin"/><seealso cref="Sin"/>
</member>
<member name="M:Tensor.Tensor`1.ApplyLayoutFn(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Tensor.Backend.TensorLayout},Microsoft.FSharp.Collections.FSharpList{Tensor.Backend.TensorLayout}},Microsoft.FSharp.Collections.FSharpList{Tensor.Tensor{`0}})">
<summary>
 Applies the given function to the tensors&apos; layouts.
</summary>
</member>
<member name="M:Tensor.Tensor`1.ApplyLayoutFn``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Tensor.Backend.TensorLayout},Microsoft.FSharp.Collections.FSharpList{Tensor.Backend.TensorLayout}},Tensor.Tensor{``0},Tensor.Tensor{``1},Tensor.Tensor{``2})">
<summary>
 Applies the given function to the tensors&apos; layouts.
</summary>
</member>
<member name="M:Tensor.Tensor`1.ApplyLayoutFn``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{Tensor.Backend.TensorLayout},Microsoft.FSharp.Collections.FSharpList{Tensor.Backend.TensorLayout}},Tensor.Tensor{``0},Tensor.Tensor{``1})">
<summary>
 Applies the given function to the tensors&apos; layouts.
</summary>
</member>
<member name="M:Tensor.Tensor`1.Acos(Tensor.Tensor{`0})">
 <summary>Element-wise arccosine (inverse cosine).</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-1.0; 0.0; 1.0]
 let b = acos a // b = [3.15159; 1.57079; 0.0]
 </code></example>
 <remarks>Computes the arccosine (inverse cosine) of each element of the specified tensor and returns them 
 as a new tensor.
 Do not call this function directly; instead use the F# <c>acos</c> function.</remarks>
 <seealso cref="FillAcos"/><seealso cref="Cos"/>
</member>
<member name="M:Tensor.Tensor`1.Abs(Tensor.Tensor{`0})">
 <summary>Element-wise absolute value.</summary>
 <param name="a">The tensor to apply this operation to.</param>
 <returns>A new tensor containing the result of this operation.</returns>
 <example><code language="fsharp">
 let a = HostTensor.ofList [-2; -1; 1]
 let b = abs a // b = [2; 1; 1]
 </code></example>
 <remarks>Computes the absolute value of each element of the specified tensor and returns them as a new tensor.
 Do not call this function directly; instead use the F# <c>abs</c> function.</remarks>
 <seealso cref="FillAbs"/>
</member>
<member name="M:Tensor.Tensor`1.#ctor(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Backend.ITensorDevice,Microsoft.FSharp.Core.FSharpOption{Tensor.TensorOrder})">
 <summary>Creates a new, uninitialized tensor with a new storage.</summary>
 <param name="shape">The shape of the tensor to create.</param>
 <param name="dev">The device to store the data of the tensor on.</param>
 <param name="order">The memory layout to use for the new tensor. (default: row-major)</param>
 <returns>The new, uninitialized tensor.</returns>
 <remarks>
 <para>The contents of the new tensor are undefined. The default memory layout is row-major.</para>
 <para>The recommended way to create a new tensor is to use <see cref="zeros"/>.</para>
 </remarks>
 <seealso cref="NewOfType"/><seealso cref="zeros"/>
</member>
<member name="T:Tensor.Tensor`1">
 <summary>An N-dimensional array with elements of type 'T.</summary>
 <typeparam name="'T">The type of the data stored within the tensor.</typeparam>
 <param name="layout">The memory layout to use.</param>
 <param name="storage">The storage to use.</param>
 <returns>A tensor using the specified memory layout and storage.</returns>
 <remarks>
 <para>The data of a tensor can be stored on different devices. Currently supported devices are host memory
 and CUDA GPU memory.</para>
 <para>Different tensors can share the whole or parts of the underlying data.</para>
 <para>The recommended way to create a new tensor is to use <see cref="zeros"/>.
 The implicit constructor creates a view into the specified storage using the specified memory layout.
 In most cases, it is not necessary to use the implicit constructor.</para>
 </remarks> 
 <seealso cref="ITensor"/> 
</member>
<member name="T:Tensor.BlockTensor`1.Block">
<summary>
 A block consisting of a single tensor.
</summary>
</member>
<member name="T:Tensor.BlockTensor`1.SubBlocks">
<summary>
 A block consisting of multiple sub-blocks.
</summary>
</member>
<member name="T:Tensor.BlockTensor`1">
 <summary>Block tensor specification.</summary>
 <typeparam name="'T">The type of the data stored within the tensor.</typeparam>
 <remarks>See <see cref="Tensor`1.ofBlocks"/> for usage information.</remarks>
 <seealso cref="Tensor`1.ofBlocks"/>
</member>
<member name="P:Tensor.SingularMatrixException.Message">
 <summary>Detailed error message.</summary>    
</member>
<member name="T:Tensor.SingularMatrixException">
 <summary>A singular matrix was encountered during an operation that does not allow singular matrices.</summary>
 <param name="msg">Detailed error message.</param>
 <remarks>
 See the documentation of the method that raised this exception for a detailed description of the error conditions.
 </remarks>
</member>
<member name="M:Tensor.HDF5Support.check``1(``0)">
<summary>
 Checks if HDF5 return value indicates success and if not,
 raises an error.
</summary>
</member>
<member name="M:Tensor.HDF5Support.raiseErr``1">
<summary>
 Raises an HDF5 error with an error message generated form the 
 current HDF5 error stack.
</summary>
</member>
<member name="T:Tensor.HDF5Support">
<summary>
 HDF5 support functions
</summary>
</member>
<member name="M:Tensor.Operators.Sgn``1(``0)">
 <summary>Sign of value returned using same type as input.</summary>
 <typeparam name="'T">Type of input and output values.</typeparam>
 <param name="x">Input value.</param>
 <returns>If <c>x&lt;0</c>, then <c>-1</c>. If <c>x=0</c>, then <c>0</c>. If <c>x&gt;0</c>, then <c>1</c>.</returns> 
 <remarks>
 <para>In contrast, the F# builtin function <c>sign</c> returns an <c>int</c> regardless of the input data type.</para>
 <para>This calls static method Sgn on non-primitive types.</para>
 </remarks>
</member>
<member name="T:Tensor.Operators">
<summary>
 Useful core operators.
</summary>
</member>
<member name="T:Tensor.Utils.DiskBinaryMap">
<summary>
 a filesystem backed map for binary keys and values
</summary>
</member>
<member name="M:Tensor.Utils.NativeLib.TryFunc``1(System.String)">
 <summary>Get delegate to native function.</summary>
 <typeparam name="'F">Delegate type of the native function.</typeparam>
 <param name="symbol">The symbol name.</param>
 <returns>A delegate to the native function or <c>Error msg</c> if the function does not exist.</returns>
</member>
<member name="M:Tensor.Utils.NativeLib.LazyFunc``1(System.String)">
 <summary>Get delegate to native function failing at invocation if function does not exists.</summary>
 <typeparam name="'F">Delegate type of the native function.</typeparam>
 <param name="symbol">The symbol name.</param>
 <returns>A delegate to the native function.</returns>
 <exception cref="SymbolNotFound">The specified symbol was not found in the library.</exception>
</member>
<member name="M:Tensor.Utils.NativeLib.HasFunc(System.String)">
 <summary>Checks if the native function exists in the library.</summary>
 <param name="symbol">The symbol name.</param>
 <returns>true if the functions exists; false otherwise.</returns>
</member>
<member name="M:Tensor.Utils.NativeLib.Func``1(System.String)">
 <summary>Get delegate to native function.</summary>
 <typeparam name="'F">Delegate type of the native function.</typeparam>
 <param name="symbol">The symbol name.</param>
 <returns>A delegate to the native function.</returns>
 <exception cref="SymbolNotFound">The specified symbol was not found in the library.</exception>
</member>
<member name="M:Tensor.Utils.NativeLib.System-IDisposable-Dispose">
 <summary>Frees the native library.</summary>
 <remarks>
 <para>This will crash your program if you use the obtained delegates after freeing the library.
 Also, the library might spawn threads, which will then crash your program, even if
 you do not perform any function call into the library.</para>
 <para>It is usually best to not free the library.</para>
 </remarks>
</member>
<member name="T:Tensor.Utils.NativeLib">
 <summary>A native library.</summary>
 <param name="libName">The name of the native library.</param>
 <exception cref="NativeLibNotLoadable">The native library could not be loaded.</exception>
</member>
<member name="T:Tensor.Utils.NativeLibName.Packaged">
 <summary>The library name is translated in an OS-specific way and searched for in the specific
 NuGet package directories.</summary>
</member>
<member name="T:Tensor.Utils.NativeLibName.Translated">
 <summary>The library name is translated in an OS-specific way.</summary>
 <remarks>If the specified name is <c>XXX</c> then Linux uses
 <c>libXXX.so</c>, Mac OS uses <c>libXXX.dylib</c> and Windows uses <c>XXX.dll</c></remarks>
</member>
<member name="T:Tensor.Utils.NativeLibName.Exact">
 <summary>The exact name is passed to the dynamic loader.</summary>
</member>
<member name="T:Tensor.Utils.NativeLibName">
 <summary>Specifies a native library name.</summary>
</member>
<member name="T:Tensor.Utils.ScalarPrimitives`2">
<summary>
 Generic scalar operation primitives.
</summary>
</member>
<member name="T:Tensor.Utils.SymbolNotFound">
<summary>
 The specified symbol was not found in the native library.
</summary>
</member>
<member name="T:Tensor.Utils.NativeLibNotLoadable">
<summary>
 The native library could not be loaded.
</summary>
</member>
<member name="M:Tensor.Utils.Exception.indexOutOfRange``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Raises an IndexOutOfRangeException.
</summary>
</member>
<member name="M:Tensor.Utils.Exception.invalidArg``2(System.String,Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Raises an InvalidArgumentException
</summary>
</member>
<member name="M:Tensor.Utils.Exception.invalidOp``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1})">
<summary>
 Raises an InvalidOperationException
</summary>
</member>
<member name="T:Tensor.Utils.Exception">
<summary>
 Exception helpers
</summary>
</member>
<member name="P:Tensor.Utils.Util.assemblyDir">
<summary>
 Directory of this assembly.
</summary>
</member>
<member name="P:Tensor.Utils.Util.assemblyPath">
<summary>
 Path to this assembly.
</summary>
</member>
<member name="M:Tensor.Utils.Util.checkProperType``1">
<summary>
 Verifies that the specified generic type is not obj or IComparable.
</summary>
</member>
<member name="M:Tensor.Utils.Util.localAppData(System.String)">
<summary>
 path to application directory under AppData\Local
</summary>
</member>
<member name="T:Tensor.Utils.Util">
<summary>
 Utility functions
</summary>
</member>
<member name="M:Tensor.Utils.Generic.callGeneric``2(System.String,Microsoft.FSharp.Collections.FSharpList{System.Type},System.Object)">
<summary>
 Calls the specified static method on the type &apos;U with the specified generic type arguments
 and the specified arguments in tupled form. Return value is of type &apos;R.
</summary>
</member>
<member name="M:Tensor.Utils.Generic.callGenericInst``2(System.Object,System.String,Microsoft.FSharp.Collections.FSharpList{System.Type},System.Object)">
<summary>
 Calls the specified method on the type &apos;U with the specified generic type arguments
 and the specified arguments in tupled form. Return value is of type &apos;R.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.sizeof64``1">
<summary>
 Size of &apos;T as int64.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.maxValue``1">
<summary>
 Maximum value for numeric type &apos;T.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.maxValueOf(System.Type)">
<summary>
 Maximum value for the specified numeric data type.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.minValue``1">
<summary>
 Minimum value for numeric type &apos;T.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.minValueOf(System.Type)">
<summary>
 Minimum value for the specifed numeric data type.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.one``1">
<summary>
 One value for type &apos;T.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.oneOf(System.Type)">
<summary>
 One value for the specifed data type.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.zero``1">
<summary>
 Zero value for type &apos;T.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.zeroOf(System.Type)">
<summary>
 Zero value for the specifed data type.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.conv``1(System.Object)">
<summary>
 Convert given value to type &apos;T.
</summary>
</member>
<member name="M:Tensor.Utils.Primitives.convTo(System.Type,System.Object)">
<summary>
 Convert given value to specified type and return as obj.
</summary>
</member>
<member name="T:Tensor.Utils.Primitives">
<summary>
 Helper functions for basic type information and conversion.
</summary>
</member>
<member name="M:Tensor.Utils.RandomExtensions.Random.SeqNormal(System.Random,System.Double,System.Double)">
<summary>
 Generates an infinite sequence of samples from a normal distribution with the given mean and variance.
</summary>
</member>
<member name="M:Tensor.Utils.RandomExtensions.Random.NextNormal(System.Random,System.Double,System.Double)">
<summary>
 Generates a sample from a normal distribution with the given mean and variance.
</summary>
</member>
<member name="M:Tensor.Utils.RandomExtensions.Random.SeqDouble(System.Random,System.Double,System.Double)">
<summary>
 Generates an infinite sequence of random numbers within the given range.
</summary>
</member>
<member name="M:Tensor.Utils.RandomExtensions.Random.SeqDouble(System.Random)">
<summary>
 Generates an infinite sequence of random numbers between 0.0 and 1.0.
</summary>
</member>
<member name="M:Tensor.Utils.RandomExtensions.Random.NextDouble(System.Random,System.Double,System.Double)">
<summary>
 Generates a random floating-point number within the given range.
</summary>
</member>
<member name="M:Tensor.Utils.RandomExtensions.Random.Seq(System.Random,System.Int32,System.Int32)">
<summary>
 Generates an infinite sequence of random integers within the given range.
</summary>
</member>
<member name="M:Tensor.Utils.RandomExtensions.Random.Seq(System.Random,System.Int32)">
<summary>
 Generates an infinite sequence of non-negative random integers that is less than the specified maximum.
</summary>
</member>
<member name="M:Tensor.Utils.RandomExtensions.Random.Seq(System.Random)">
<summary>
 Generates an infinite sequence of non-negative random integers.
</summary>
</member>
<member name="T:Tensor.Utils.RandomExtensions">
<summary>
 Extensions to System.Random.
</summary>
</member>
<member name="T:Tensor.Utils.CollectionExtensions">
<summary>
 Extension methods for common collection types.
</summary>
</member>
<member name="M:Tensor.Utils.Permutation.|Swap|_|(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 permutation is a swap of two elements
</summary>
</member>
<member name="M:Tensor.Utils.Permutation.apply``1(Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 permutes the list using the given permutation
</summary>
</member>
<member name="M:Tensor.Utils.Permutation.chain(Microsoft.FSharp.Collections.FSharpList{System.Int32},Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 returns the permutation that would result in applying perm1 after perm2    
</summary>
</member>
<member name="M:Tensor.Utils.Permutation.invert(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 inverts the given permutation
</summary>
</member>
<member name="M:Tensor.Utils.Permutation.identity(System.Int32)">
<summary>
 identity permutation of given size
</summary>
</member>
<member name="M:Tensor.Utils.Permutation.isIdentity(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 true if then given permutation is the identity permutation
</summary>
</member>
<member name="M:Tensor.Utils.Permutation.length(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 the length of the given permutation
</summary>
</member>
<member name="M:Tensor.Utils.Permutation.is(Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 true if the given list is a permutation of the numbers 0 to perm.Length-1
</summary>
</member>
<member name="T:Tensor.Utils.Permutation">
<summary>
 Functions for working with permutations.
</summary>
</member>
<member name="M:Tensor.Utils.List.insert``1(System.Int32,``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 insert the specified value at index elem
</summary>
</member>
<member name="M:Tensor.Utils.List.without``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 removes element with index elem 
</summary>
</member>
<member name="M:Tensor.Utils.List.set``1(System.Int32,``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 sets element with index elem to given value
</summary>
</member>
<member name="T:Tensor.Utils.List">
<summary>
 List extensions
</summary>
</member>
<member name="T:Tensor.Utils.ScalarPrimitives">
<summary>
 Generic scalar operation primitives.
</summary>
</member>
<member name="P:Tensor.SpecialIdx.NotFound">
<summary>
 For search: value was not found.
</summary>
</member>
<member name="P:Tensor.SpecialIdx.Remainder">
<summary>
 For reshape: remainder, so that number of elements stays constant.
</summary>
</member>
<member name="P:Tensor.SpecialIdx.Fill">
<summary>
 For slicing: fills all remaining axes with size one. 
 Cannot be used together with NewAxis.
</summary>
</member>
<member name="P:Tensor.SpecialIdx.NewAxis">
<summary>
 For slicing: inserts a new axis of size one.
</summary>
</member>
<member name="T:Tensor.SpecialIdx">
<summary>
 Special constants that can be passed or returned instead of indices.
</summary>
</member>
<member name="M:Tensor.ITensorModule.transfer(Tensor.Backend.ITensorDevice,Tensor.ITensor)">
 <summary>Transfers a tensor to the specifed device.</summary>
 <param name="dev">The target device.</param>
 <param name="a">The tensor to transfer.</param>
 <returns>A tensor on the target device.</returns>
 <seealso cref="Tensor`1.transfer"/>
</member>
<member name="M:Tensor.ITensorModule.copy(Tensor.ITensor)">
 <summary>Returns a copy of the tensor.</summary>
 <param name="a">The tensor to copy.</param>
 <param name="order">The memory layout of the copy. (default: row-major)</param>
 <returns>A copy of the tensor.</returns>
 <seealso cref="Tensor`1.copy"/>
</member>
<member name="M:Tensor.ITensorModule.atLeast3D(Tensor.ITensor)">
 <summary>Pads the tensor from the left with size-one dimensions until it has at least three dimensions.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>A tensor with at least three dimensions.</returns>
 <seealso cref="Tensor`1.atLeast3D"/>
</member>
<member name="M:Tensor.ITensorModule.atLeast2D(Tensor.ITensor)">
 <summary>Pads the tensor from the left with size-one dimensions until it has at least two dimensions.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>A tensor with at least two dimensions.</returns>
 <seealso cref="Tensor`1.atLeast2D"/>
</member>
<member name="M:Tensor.ITensorModule.atLeast1D(Tensor.ITensor)">
 <summary>Pads the tensor from the left with size-one dimensions until it has at least one dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>A tensor with at least one dimensions.</returns>
 <seealso cref="Tensor`1.atLeast1D"/>
</member>
<member name="M:Tensor.ITensorModule.atLeastND(System.Int32,Tensor.ITensor)">
 <summary>Pads the tensor from the left with size-one dimensions until it has at least the specified number of
 dimensions.</summary>
 <param name="minDims">The minimum number of dimensions.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>A tensor with at least <paramref name="minDims"/> dimensions.</returns>
 <seealso cref="Tensor`1.atLeastND"/>
</member>
<member name="M:Tensor.ITensorModule.reverseAxis(System.Int32,Tensor.ITensor)">
 <summary>Reverses the elements in the specified dimension.</summary>
 <param name="ax">The axis to reverse.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The tensor with the dimensions permuted.</returns>
 <seealso cref="Tensor`1.reverseAxis"/>
</member>
<member name="M:Tensor.ITensorModule.permuteAxes(Microsoft.FSharp.Collections.FSharpList{System.Int32},Tensor.ITensor)">
 <summary>Permutes the axes as specified.</summary>
 <param name="permut">The permutation to apply to the dimensions of tensor.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The tensor with the dimensions permuted.</returns>
 <seealso cref="Tensor`1.permuteAxes"/>
</member>
<member name="M:Tensor.ITensorModule.transpose(Tensor.ITensor)">
 <summary>Transpose of a matrix.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>The result of this operation.</returns>
 <seealso cref="Tensor`1.transpose"/>
</member>
<member name="M:Tensor.ITensorModule.swapDim(System.Int32,System.Int32,Tensor.ITensor)">
 <summary>Swaps the specified dimensions of the tensor.</summary>
 <param name="ax1">The dimension to swap.</param>
 <param name="ax2">The dimension to swap with.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The tensor with the dimensions swapped.</returns>
 <seealso cref="Tensor`1.swapDim"/>
</member>
<member name="M:Tensor.ITensorModule.flatten(Tensor.ITensor)">
 <summary>Flattens the tensor into a (one-dimensional) vector.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>A vector.</returns>
 <seealso cref="Tensor`1.flatten"/>
</member>
<member name="M:Tensor.ITensorModule.reshape(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.ITensor)">
 <summary>Changes the shape of a tensor.</summary>
 <param name="shp">The target shape.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>A tensor of the specified shape.</returns>
 <seealso cref="Tensor`1.reshape"/>
</member>
<member name="M:Tensor.ITensorModule.reshapeView(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.ITensor)">
 <summary>Creates a reshaped view of the tensor (without copying).</summary>
 <param name="shp">The target shape.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>A reshaped view of the original tensor.</returns>
 <seealso cref="Tensor`1.reshapeView"/>
</member>
<member name="M:Tensor.ITensorModule.tryReshapeView(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.ITensor)">
 <summary>Tries to create a reshaped view of the tensor (without copying).</summary>
 <param name="shp">The target shape.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The reshaped tensor, if reshaping without copying is possible. Otherwise <c>None</c>.</returns>
 <seealso cref="Tensor`1.tryReshapeView"/>
</member>
<member name="M:Tensor.ITensorModule.isBroadcasted(Tensor.ITensor)">
 <summary>Checks if the specified tensor is broadcasted in at least one dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>true if at least one dimension is broadcasted, otherwise false.</returns>
 <seealso cref="Tensor`1.isBroadcasted"/>
</member>
<member name="M:Tensor.ITensorModule.broadcastTo(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.ITensor)">
 <summary>Broadcasts the specified tensor to the specified shape.</summary>
 <param name="shp">The target shape.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>Tensor of shape <paramref name="shp"/>.</returns>
 <seealso cref="Tensor`1.broadcastTo"/>
</member>
<member name="M:Tensor.ITensorModule.broadcastToSameInDims(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Collections.FSharpList{Tensor.ITensor})">
 <summary>Broadcasts all specified tensors to have the same size in the specified dimensions.</summary>
 <param name="dims">A list of dimensions that should be broadcasted to have the same size.</param>
 <param name="xs">A list of tensors to operate on.</param>
 <returns>A list of the resulting tensors, all having the same size in the specified dimensions.</returns>
 <seealso cref="Tensor`1.broadcastToSameInDims"/>
</member>
<member name="M:Tensor.ITensorModule.broadcastToSame(Microsoft.FSharp.Collections.FSharpList{Tensor.ITensor})">
 <summary>Broadcasts all specified tensors to have the same shape.</summary>
 <param name="xs">A list of tensors to operate on.</param>    
 <returns>A list of the resulting tensors, all having the same shape.</returns>
 <seealso cref="Tensor`1.broadcastToSame"/>
</member>
<member name="M:Tensor.ITensorModule.padToSame(Microsoft.FSharp.Collections.FSharpList{Tensor.ITensor})">
 <summary>Pads all specified tensors from the left with dimensions of size one until they have the 
 same dimensionality.</summary>
 <param name="xs">A list of tensors to operate on.</param>
 <returns>A list of the resulting tensors, all having the same dimensionality.</returns>
 <seealso cref="Tensor`1.padToSame"/>
</member>
<member name="M:Tensor.ITensorModule.broadcastDim(System.Int32,System.Int64,Tensor.ITensor)">
 <summary>Broadcast a dimension to a specified size.</summary>
 <param name="dim">The size-one dimension to broadcast.</param>
 <param name="size">The size to broadcast to.</param>    
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <seealso cref="Tensor`1.broadcastDim"/>
</member>
<member name="M:Tensor.ITensorModule.cutRight(Tensor.ITensor)">
 <summary>Removes the last dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <seealso cref="Tensor`1.cutRight"/>
</member>
<member name="M:Tensor.ITensorModule.cutLeft(Tensor.ITensor)">
 <summary>Removes the first dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <seealso cref="Tensor`1.cutLeft"/>
</member>
<member name="M:Tensor.ITensorModule.insertAxis(System.Int32,Tensor.ITensor)">
 <summary>Insert a dimension of size one before the specifed dimension.</summary>
 <param name="ax">The dimension to insert before.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <seealso cref="Tensor`1.insertAxis"/>
</member>
<member name="M:Tensor.ITensorModule.padRight(Tensor.ITensor)">
 <summary>Append a dimension of size one after the last dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <seealso cref="Tensor`1.padRight"/>
</member>
<member name="M:Tensor.ITensorModule.padLeft(Tensor.ITensor)">
 <summary>Insert a dimension of size one as the first dimension.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <seealso cref="Tensor`1.padLeft"/>
</member>
<member name="M:Tensor.ITensorModule.allIdx(Tensor.ITensor)">
 <summary>Gets a sequence of all indices to enumerate all elements within the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Sequence of indicies.</returns>
 <remarks>The sequence sequentially enumerates the indices of all elements of the tensor.</remarks>
 <seealso cref="Tensor`1.allIdxOfDim"/>
</member>
<member name="M:Tensor.ITensorModule.range(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng},Tensor.ITensor)">
 <summary>Get a slice (part) of the tensor.</summary>
 <param name="rng">The range of the tensor to select.</param>    
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <seealso cref="Tensor`1.range"/>
</member>
<member name="M:Tensor.ITensorModule.relayout(Tensor.Backend.TensorLayout,Tensor.ITensor)">
 <summary>Creates a tensor with the specified layout sharing its storage with the original tensor.</summary>
 <param name="newLayout">The new tensor memory layout.</param>
 <param name="a">The tensor to operate on.</param>
 <returns>The resulting tensor.</returns>
 <seealso cref="Tensor`1.relayout"/>
</member>
<member name="M:Tensor.ITensorModule.dataType(Tensor.ITensor)">
 <summary>Type of data stored within the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Data type.</returns>
 <seealso cref="Tensor`1.DataType"/>
</member>
<member name="M:Tensor.ITensorModule.nElems(Tensor.ITensor)">
 <summary>Total number of elements within the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Number of elements.</returns>
 <seealso cref="Tensor`1.NElems"/>
</member>
<member name="M:Tensor.ITensorModule.nDims(Tensor.ITensor)">
 <summary>Dimensionality of the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Number of dimensions.</returns>
 <seealso cref="Tensor`1.NDims"/>
</member>
<member name="M:Tensor.ITensorModule.shape(Tensor.ITensor)">
 <summary>Shape of the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Shape.</returns>
 <seealso cref="Tensor`1.Shape"/>
</member>
<member name="M:Tensor.ITensorModule.dev(Tensor.ITensor)">
 <summary>Device the data of tensor is stored on.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Data storage device.</returns>
 <seealso cref="Tensor`1.Dev"/>
</member>
<member name="M:Tensor.ITensorModule.layout(Tensor.ITensor)">
 <summary>Memory layout of the tensor.</summary>
 <param name="a">The tensor to operate on.</param>
 <returns>Memory layout.</returns>
 <seealso cref="Tensor`1.Layout"/>
</member>
<member name="T:Tensor.ITensorModule">
 <summary>Type-neutral interface to Tensor&lt;'T&gt; of any type 'T.</summary>
 <remarks>These functions are useful for working with tensors of unknown types.
 For most use cases the functions provided by <see cref="Tensor`1"/> are better suited.</remarks>
 <seealso cref="Tensor`1"/>
</member>
<member name="P:Tensor.SpecialMask.NoMask">
<summary>
 Indicates that the dimension is unmasked, i.e. equals specifying a tensor filled with trues. 
</summary>
</member>
<member name="T:Tensor.SpecialMask">
<summary>
 Special values that can be passed instead of masks.
</summary>
</member>
<member name="P:Tensor.TensorVal.NoMask">
 <summary>Indicates that the dimension is unmasked, i.e. equals specifying a tensor filled with trues.</summary>
</member>
<member name="P:Tensor.TensorVal.NotFound">
 <summary>For search: value was not found.</summary>
</member>
<member name="P:Tensor.TensorVal.Remainder">
 <summary>For reshape: remainder, so that number of elements stays constant.</summary>
</member>
<member name="P:Tensor.TensorVal.Fill">
 <summary>For slicing: fills all remaining axes with size one.</summary> 
 <remarks>Cannot be used together with <see cref="NewAxis"/>.</remarks>
</member>
<member name="P:Tensor.TensorVal.NewAxis">
 <summary>For slicing: inserts a new axis of size one.</summary>
</member>
<member name="T:Tensor.TensorVal">
 <summary>Special constants that can be passed instead of indicies or parameter values or be returned 
 from methods.</summary>
</member>
<member name="P:Tensor.Backend.TensorLayout.Stride">
<summary>
 Stride in elements.
</summary>
</member>
<member name="P:Tensor.Backend.TensorLayout.Offset">
<summary>
 Offset (to first element) in elements.
</summary>
</member>
<member name="P:Tensor.Backend.TensorLayout.Shape">
<summary>
 Shape.
</summary>
</member>
<member name="P:Tensor.Backend.TensorLayout.NElems">
<summary>
 Number of elements.
</summary>
</member>
<member name="P:Tensor.Backend.TensorLayout.NDims">
<summary>
 Number of dimensions.
</summary>
</member>
<member name="T:Tensor.Backend.TensorLayout">
<summary>
 Layout (shape, offset, stride) of a Tensor.
</summary>
</member>
<member name="T:Tensor.Backend.BaseTensorDevice">
<summary>
 Base tensor device.
</summary>
</member>
<member name="T:Tensor.Backend.ITensorBackend`1">
<summary>
 Tensor backend.
</summary>
</member>
<member name="P:Tensor.Backend.ITensorFrontend`1.T">
<summary>
 Transpose
</summary>
</member>
<member name="P:Tensor.Backend.ITensorFrontend`1.Stride">
<summary>
 stride
</summary>
</member>
<member name="P:Tensor.Backend.ITensorFrontend`1.Storage">
<summary>
 storage of this tensor
</summary>
</member>
<member name="P:Tensor.Backend.ITensorFrontend`1.Shape">
<summary>
 shape
</summary>
</member>
<member name="P:Tensor.Backend.ITensorFrontend`1.Offset">
<summary>
 stride
</summary>
</member>
<member name="P:Tensor.Backend.ITensorFrontend`1.NElems">
<summary>
 number of elements
</summary>
</member>
<member name="P:Tensor.Backend.ITensorFrontend`1.NDims">
<summary>
 number of dimensions
</summary>
</member>
<member name="P:Tensor.Backend.ITensorFrontend`1.Layout">
<summary>
 layout of this tensor (shape, offset and strides)
</summary>
</member>
<member name="P:Tensor.Backend.ITensorFrontend`1.Dev">
<summary>
 storage factory
</summary>
</member>
<member name="P:Tensor.Backend.ITensorFrontend`1.Backend">
<summary>
 the backend    
</summary>
</member>
<member name="M:Tensor.Backend.ITensorFrontend`1.Transfer(Tensor.Backend.ITensorDevice)">
<summary>
 Transfers this tensor to the specifed device.
</summary>
</member>
<member name="M:Tensor.Backend.ITensorFrontend`1.Relayout(Tensor.Backend.TensorLayout)">
<summary>
 a tensor with the same storage but new layout
</summary>
</member>
<member name="M:Tensor.Backend.ITensorFrontend`1.CopyFrom(Tensor.Backend.ITensorFrontend{`0})">
<summary>
 Copies the specifed tensor into this tensor.
</summary>
</member>
<member name="M:Tensor.Backend.ITensorFrontend`1.Copy(Microsoft.FSharp.Core.FSharpOption{Tensor.TensorOrder})">
<summary>
 returns a copy of the tensor
</summary>
</member>
<member name="T:Tensor.Backend.ITensorFrontend`1">
<summary>
 Tensor frontend access (for use from backend).
</summary>
</member>
<member name="T:Tensor.Backend.ITensorDevice">
<summary>
 Tensor device.
</summary>
</member>
<member name="T:Tensor.Backend.ITensorStorage`1">
<summary>
 Tensor storage.
</summary>
</member>
<member name="T:Tensor.Backend.ITensorStorage">
<summary>
 Tensor storage (type neutral).
</summary>
</member>
<member name="M:Tensor.Backend.BLAS.MatrixOrder(System.Int32)">
<summary>
 best order for matrix
</summary>
</member>
<member name="M:Tensor.Backend.BLAS.Invoke``2(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1}},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1}})">
<summary>
 Call BLAS/LAPACK function depending on data type.
</summary>
</member>
<member name="M:Tensor.Backend.BLAS.GetVectorInfo``1(Tensor.Backend.ITensorFrontend{``0},System.Boolean,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
<summary>
 Internal function for GetBlasVector.
</summary>
</member>
<member name="M:Tensor.Backend.BLAS.GetVector``1(Tensor.Backend.ITensorFrontend{``0},System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Boolean},Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Returns a BlasVectorInfo that exposes the specfied vector to BLAS
 as a source and/or target. 
 When allowCopy is true, then:
 - the source might be copied into a temporary tensor,
 - the result might be copied from a temporary tensor into the target, when
   the returned BlasMatrixInfo is disposed.
 When reqLinear is true, it ensures that the resulting vector is
 densely packed, i.e. has increment one.
</summary>
</member>
<member name="M:Tensor.Backend.BLAS.GetScalar``1(Tensor.Backend.ITensorFrontend{``0})">
<summary>
 Returns a Blas.ScalarInfo that exposes the specfied scalar to BLAS
 as a source and/or target. 
</summary>
</member>
<member name="M:Tensor.Backend.BLAS.GetMatrixInfo``1(Tensor.Backend.ITensorFrontend{``0},System.Boolean,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}})">
<summary>
 Internal function for GetBlasMatrix.
</summary>
</member>
<member name="M:Tensor.Backend.BLAS.GetMatrix``1(Tensor.Backend.ITensorFrontend{``0},System.Boolean,System.Boolean,System.Boolean,Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Returns a BlasMatrixInfo that exposes the specfied matrix to BLAS
 as a source and/or target. 
 If canTranpose is true, then the BLAS call must accept a tranpose parameter.
 When allowCopy is true, then:
 - the source might be copied into a temporary tensor,
 - the result might be copied from a temporary tensor into the target, when
   the returned BlasMatrixInfo is disposed.
</summary>
</member>
<member name="T:Tensor.Backend.BLAS">
<summary>
 backend-neutral BLAS support 
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.linearToIdx(Tensor.Backend.TensorLayout,System.Int64)">
<summary>
 Computes the index of a given linear index.
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.idxToLinear(Tensor.Backend.TensorLayout,Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 Computes the linear index of a given index.
 Linear indexing is performed in row-major order.
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.diagAxis(System.Int32,System.Int32,Tensor.Backend.TensorLayout)">
<summary>
 Creates a layout that extracts the diagonal along the given axes.
 The first axis is replaced with the diagonal and the second axis is removed.
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.view(Microsoft.FSharp.Collections.FSharpList{Tensor.Rng},Tensor.Backend.TensorLayout)">
<summary>
 creates a subview layout
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.reverseAxis(System.Int32,Tensor.Backend.TensorLayout)">
<summary>
 Reverses the elements in the specified dimension.
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.permuteAxes(Microsoft.FSharp.Collections.FSharpList{System.Int32},Tensor.Backend.TensorLayout)">
<summary>
 Permutes the axes as specified.
 Each entry in the specified permutation specifies the *new* position of 
 the corresponding axis, i.e. to which position the axis should move.
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.transpose(Tensor.Backend.TensorLayout)">
<summary>
 Transposes the given layout of a matrix.
 If the array has more then two dimensions, the last two axes are swapped.
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.swapDim(System.Int32,System.Int32,Tensor.Backend.TensorLayout)">
<summary>
 swaps the given dimensions
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.reshape(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Backend.TensorLayout)">
<summary>
 Reshape layout under the assumption that it is contiguous.
 The number of elements must not change.
 An error is raised, if reshape is impossible without copying.
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.canReshape(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Backend.TensorLayout)">
<summary>
 Returns true if a can be reshaped into shp without copying.
 The number of elements must not change.
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.tryReshape(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Backend.TensorLayout)">
<summary>
 Reshape layout under the assumption that it is contiguous.
 The number of elements must not change.
 Returns Some newLayout when reshape is possible without copy
 Returns None when a copy is required.
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.isBroadcasted(Tensor.Backend.TensorLayout)">
<summary>
 returns true if at least one dimension is broadcasted
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.broadcastToShape(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Backend.TensorLayout)">
<summary>
 broadcasts a tensor to the given shape
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.broadcastToSameMany(Microsoft.FSharp.Collections.FSharpList{Tensor.Backend.TensorLayout})">
<summary>
 broadcasts to have the same size
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.broadcastToSame(Tensor.Backend.TensorLayout,Tensor.Backend.TensorLayout)">
<summary>
 broadcasts to have the same size
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.broadcastToSameInDimsMany(System.Collections.Generic.IEnumerable{System.Int32},Microsoft.FSharp.Collections.FSharpList{Tensor.Backend.TensorLayout})">
<summary>
 broadcasts to have the same size in the given dimensions    
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.broadcastToSameInDims(System.Collections.Generic.IEnumerable{System.Int32},Tensor.Backend.TensorLayout,Tensor.Backend.TensorLayout)">
<summary>
 broadcasts to have the same size in the given dimensions
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.padToSameMany(Microsoft.FSharp.Collections.FSharpList{Tensor.Backend.TensorLayout})">
<summary>
 pads shapes from the left until they have same rank
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.padToSame(Tensor.Backend.TensorLayout,Tensor.Backend.TensorLayout)">
<summary>
 pads shapes from the left until they have same rank
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.broadcastDim(System.Int32,System.Int64,Tensor.Backend.TensorLayout)">
<summary>
 broadcast the given dimension to the given size
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.cutRight(Tensor.Backend.TensorLayout)">
<summary>
 cuts one dimension from the right
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.cutLeft(Tensor.Backend.TensorLayout)">
<summary>
 cuts one dimension from the left
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.insertAxis(System.Int32,Tensor.Backend.TensorLayout)">
<summary>
 Inserts an axis of size 1 before the specified position.
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.padRight(Tensor.Backend.TensorLayout)">
<summary>
 adds a new dimension of size one to the right
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.padLeft(Tensor.Backend.TensorLayout)">
<summary>
 adds a new dimension of size one to the left
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.hasContiguousMemory(Tensor.Backend.TensorLayout)">
<summary>
 true if the memory of the ArrayND is a contiguous block
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.isF(Tensor.Backend.TensorLayout)">
<summary>
 true if the ArrayND is in Fortran order
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.isC(Tensor.Backend.TensorLayout)">
<summary>
 true if the ArrayND is contiguous
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.stridesEqual(Microsoft.FSharp.Collections.FSharpList{System.Int64},Microsoft.FSharp.Collections.FSharpList{System.Int64},Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 True if strides are equal at all dimensions with size &gt; 1.
</summary>
</member>
<member name="P:Tensor.Backend.TensorLayoutModule.emptyVector">
<summary>
 an ArrayND layout for an empty (zero elements) vector (1D)
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.newF(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 a Fortran-order (column-major) ArrayND layout of the given shape 
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.newC(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 a C-order (row-major) ArrayND layout of the given shape 
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.newOrdered(Microsoft.FSharp.Collections.FSharpList{System.Int64},Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 a ArrayND layout of the given shape and stride order
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.fStride(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 computes the stride given the shape for the ArrayND to be in Fortran-order (column-major)
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.cStride(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 computes the stride given the shape for the ArrayND to be in C-order (row-major)
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.orderedStride(Microsoft.FSharp.Collections.FSharpList{System.Int64},Microsoft.FSharp.Collections.FSharpList{System.Int32})">
<summary>
 Computes the strides for the given shape using the specified ordering.
 The axis that is first in the ordering gets stride 1.
 The resulting strides will be independent of the shape of the axis 
 that appears last in the ordering.
 A C-order stride corresponds to the ordering: [n; n-1; ...; 2; 1; 0].
 A Fortran-order stride corresponds to the ordering: [0; 1; 2; ...; n-1; n].
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.allIdxOfDim(System.Int32,Tensor.Backend.TensorLayout)">
<summary>
 all indices of the given dimension
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.allIdx(Tensor.Backend.TensorLayout)">
<summary>
 sequence of all indices 
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.allIdxOfShape(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 a sequence of indicies enumerating all elements of the array with the given shape
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.checkAxis(System.Int32,Tensor.Backend.TensorLayout)">
<summary>
 checks that the given axis is valid 
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.nElems(Tensor.Backend.TensorLayout)">
<summary>
 number of elements 
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.nDims(Tensor.Backend.TensorLayout)">
<summary>
 number of dimensions
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.offset(Tensor.Backend.TensorLayout)">
<summary>
 offset 
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.stride(Tensor.Backend.TensorLayout)">
<summary>
 stride
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.shape(Tensor.Backend.TensorLayout)">
<summary>
 shape 
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.addr(Microsoft.FSharp.Collections.FSharpList{System.Int64},Tensor.Backend.TensorLayout)">
<summary>
 address of element
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.checkIndex(Microsoft.FSharp.Collections.FSharpList{System.Int64},Microsoft.FSharp.Collections.FSharpList{System.Int64})">
<summary>
 checks that the given index is valid for the given shape
</summary>
</member>
<member name="M:Tensor.Backend.TensorLayoutModule.check(Tensor.Backend.TensorLayout)">
<summary>
 checks that the layout is valid
</summary>
</member>
<member name="T:Tensor.Backend.TensorLayoutModule">
<summary>
 Functions for working with TensorLayout.
</summary>
</member>
<member name="T:Tensor.Backend.BLASModule.ScalarInfo">
<summary>
 Information for passing a scalar to BLAS/LAPACK routines.
</summary>
</member>
<member name="T:Tensor.Backend.BLASModule.VectorInfo">
<summary>
 Information for passing a vector to BLAS/LAPACK routines.
</summary>
</member>
<member name="T:Tensor.Backend.BLASModule.MatrixInfo">
<summary>
 Information for passing a matrix to BLAS/LAPACK routines.
</summary>
</member>
<member name="T:Tensor.Backend.BLASModule.Transposition">
<summary>
 BLAS Transposition
</summary>
</member>
<member name="M:Tensor.Backend.BLASModule.IBLASStorage.Pin">
<summary>
 pin memory and return handle to unpin and pointer to memory
</summary>
</member>
<member name="T:Tensor.Backend.BLASModule.IBLASStorage">
<summary>
 storage that supports pinning of memory for BLAS
</summary>
</member>
<member name="T:Tensor.Backend.BLASModule">
<summary>
 backend-neutral BLAS support 
</summary>
</member>
<member name="P:Tensor.Host.Cfg.BLASLib(Tensor.Host.BLASLib)">
 <summary>The BLAS and LAPACK library to use.</summary>
 <remarks>
 <para>This setting is global to the all threads.</para>
 </remarks>
</member>
<member name="M:Tensor.Host.Cfg.remove_BLASLibChangedEvent(Microsoft.FSharp.Control.FSharpHandler{Tensor.Host.BLASLib})">
 <summary>BLAS library was changed.</summary>
</member>
<member name="P:Tensor.Host.Cfg.BLASLibChangedEvent">
 <summary>BLAS library was changed.</summary>
</member>
<member name="P:Tensor.Host.Cfg.BLASLib">
 <summary>The BLAS and LAPACK library to use.</summary>
 <remarks>
 <para>This setting is global to the all threads.</para>
 </remarks>
</member>
<member name="M:Tensor.Host.Cfg.add_BLASLibChangedEvent(Microsoft.FSharp.Control.FSharpHandler{Tensor.Host.BLASLib})">
 <summary>BLAS library was changed.</summary>
</member>
<member name="T:Tensor.Host.Cfg">
 <summary>Options for configuring operations performed on hosts tensors.</summary>
 <seealso cref="HostTensor"/>
</member>
<member name="T:Tensor.Host.BLASLib.Custom">
 <summary>Custom BLAS and LAPACK libraries.</summary>
 <param name="blas">Name of BLAS native library.</param>
 <param name="lapack">Name of LAPACK native library.</param>
</member>
<member name="T:Tensor.Host.BLASLib.OpenBLAS">
 <summary>OpenBLAS BLAS and LAPACK</summary>
</member>
<member name="T:Tensor.Host.BLASLib.IntelMKL">
 <summary>Intel MKL BLAS and LAPACK</summary>
</member>
<member name="T:Tensor.Host.BLASLib.Vendor">
 <summary>Vendor BLAS and LAPACK.</summary>
 <remarks>This uses the system BLAS and LAPACK libraries by loading the shared libaries with the following names.
 Windows: blas.dll and lapacke.dll.
 Linux: libblas.so and liblapacke.so.
 Mac OS: libblas.dylib and liblapacke.dylib.
 </remarks>
</member>
<member name="T:Tensor.Host.BLASLib">
 <summary>BLAS and LAPACK libraries.</summary>
 <seealso cref="Cfg.BLAS"/>
</member>
<member name="P:Tensor.Host.BLAS.F">
<summary>
 Access to actual implementation 
</summary>
</member>
<member name="T:Tensor.Host.BLAS">
<summary>
 BLAS / LAPACK library 
</summary>
</member>
<member name="T:Tensor.Host.DataAndLayout`1">
<summary>
 Data and fast layout of a host tensor.
</summary>
</member>
<member name="T:Tensor.Host.PosIter32">
<summary>
 Fast index operations.
</summary>
</member>
<member name="T:Tensor.Host.FastLayout32">
<summary>
 Fast layout operations.
</summary>
</member>
<member name="T:Tensor.Host.ScalarOps">
<summary>
 Scalar operations on host tensors.
</summary>
</member>
<member name="T:Tensor.Host.VectorOps">
<summary>
 Vectorized (SIMD) operations on host tensors.
</summary>
</member>
<member name="T:Tensor.Host.TensorHostDevice">
<summary>
 Factory for host tensors.
</summary>
</member>
<member name="F:Tensor.Host.TensorHostBackend`1.Data@">
<summary>
 underlying data array
</summary>
</member>
<member name="F:Tensor.Host.TensorHostBackend`1.FastLayout@">
<summary>
 fast layout
</summary>
</member>
<member name="F:Tensor.Host.TensorHostBackend`1.isBlasSupported">
<summary>
 true if BLAS operations support type &apos;T 
</summary>
</member>
<member name="P:Tensor.Host.TensorHostBackend`1.Storage">
<summary>
 underlying TensorHostStorate&lt;&apos;T&gt;
</summary>
</member>
<member name="P:Tensor.Host.TensorHostBackend`1.FastLayout">
<summary>
 fast layout
</summary>
</member>
<member name="P:Tensor.Host.TensorHostBackend`1.DataAndLayout">
<summary>
 data array and fast layout
</summary>
</member>
<member name="P:Tensor.Host.TensorHostBackend`1.Data">
<summary>
 underlying data array
</summary>
</member>
<member name="M:Tensor.Host.TensorHostBackend`1.GetDataAndLayout``2(Tensor.Backend.ITensorFrontend{`0},Tensor.Backend.ITensorFrontend{``0},Tensor.Backend.ITensorFrontend{``1})">
<summary>
 gets DataAndLayout for specified tensors
</summary>
</member>
<member name="M:Tensor.Host.TensorHostBackend`1.GetDataAndLayout``1(Tensor.Backend.ITensorFrontend{`0},Tensor.Backend.ITensorFrontend{``0})">
<summary>
 gets DataAndLayout for specified tensors
</summary>
</member>
<member name="M:Tensor.Host.TensorHostBackend`1.GetDataAndLayout(Tensor.Backend.ITensorFrontend{`0})">
<summary>
 gets DataAndLayout for specified tensors
</summary>
</member>
<member name="M:Tensor.Host.TensorHostBackend`1.ElemwiseLayouts(Tensor.Backend.TensorLayout,Microsoft.FSharp.Collections.FSharpList{Tensor.Backend.TensorLayout})">
<summary>
 gets layouts for specified targets and sources, optimized for an element-wise operation
</summary>
</member>
<member name="M:Tensor.Host.TensorHostBackend`1.ElemwiseDataAndLayout``3(Tensor.Backend.ITensorFrontend{`0},Tensor.Backend.ITensorFrontend{``0},Tensor.Backend.ITensorFrontend{``1},Tensor.Backend.ITensorFrontend{``2})">
<summary>
 gets DataAndLayout for specified tensors, optimized for an element-wise operation
</summary>
</member>
<member name="M:Tensor.Host.TensorHostBackend`1.ElemwiseDataAndLayout``2(Tensor.Backend.ITensorFrontend{`0},Tensor.Backend.ITensorFrontend{``0},Tensor.Backend.ITensorFrontend{``1})">
<summary>
 gets DataAndLayout for specified tensors, optimized for an element-wise operation
</summary>
</member>
<member name="M:Tensor.Host.TensorHostBackend`1.ElemwiseDataAndLayout``1(Tensor.Backend.ITensorFrontend{`0},Tensor.Backend.ITensorFrontend{``0})">
<summary>
 gets DataAndLayout for specified tensors, optimized for an element-wise operation
</summary>
</member>
<member name="M:Tensor.Host.TensorHostBackend`1.ElemwiseDataAndLayout(Tensor.Backend.ITensorFrontend{`0})">
<summary>
 gets DataAndLayout for specified tensors, optimized for an element-wise operation
</summary>
</member>
<member name="T:Tensor.Host.TensorHostBackend`1">
<summary>
 Backend for host tensors.
</summary>
</member>
<member name="P:Tensor.Host.TensorHostStorage`1.DataSizeInBytes">
<summary>
 size of underlying data array in bytes
</summary>
</member>
<member name="P:Tensor.Host.TensorHostStorage`1.DataSize">
<summary>
 size of underlying data array in elements
</summary>
</member>
<member name="P:Tensor.Host.TensorHostStorage`1.Data">
<summary>
 the underlying data array
</summary>
</member>
<member name="M:Tensor.Host.TensorHostStorage`1.Pin">
<summary>
 pins the underlying data array and returns the corresponding pinned memory
</summary>
</member>
<member name="M:Tensor.Host.TensorHostStorage`1.#ctor(System.Int64)">
<summary>
 allocates a new data array with the given number of elements
</summary>
</member>
<member name="T:Tensor.Host.TensorHostStorage`1">
<summary>
 Storage (using a .NET array) for host tensors.
</summary>
</member>
<member name="P:Tensor.Host.ITensorHostStorage.DataSizeInBytes">
<summary>
 size of underlying data array in bytes
</summary>
</member>
<member name="P:Tensor.Host.ITensorHostStorage.DataSize">
<summary>
 size of underlying data array in elements
</summary>
</member>
<member name="P:Tensor.Host.ITensorHostStorage.Data">
<summary>
 the underlying data array
</summary>
</member>
<member name="M:Tensor.Host.ITensorHostStorage.Pin">
<summary>
 pins the underlying data array and returns the corresponding pinned memory
</summary>
</member>
<member name="T:Tensor.Host.ITensorHostStorage">
<summary>
 type-neutral interface to TensorHostStorage&lt;&apos;T&gt;
</summary>
</member>
<member name="P:Tensor.Host.PinnedMemory.Size">
<summary>
 size of storage array in bytes
</summary>
</member>
<member name="P:Tensor.Host.PinnedMemory.Ptr">
<summary>
 pointer to storage array 
</summary>
</member>
<member name="T:Tensor.Host.PinnedMemory">
<summary>
 pinned .NET managed memory (wraps a GCHandle)
</summary>
</member>
<member name="T:Tensor.Host.BLASModule.Impl">
<summary>
 BLAS/LAPACK native library 
</summary>
</member>
<member name="T:Tensor.Host.BLASModule">
<summary>
 BLAS / LAPACK library 
</summary>
</member>
<member name="M:Tensor.HostTensor.foldAxis``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Tensor.Tensor{``0},System.Int32,Tensor.Tensor{``1})">
 <summary>Applies to specified function to all elements of the tensor, threading an accumulator through the 
 computation.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="fn">A function that takes a state value and a value from the input tensor and returns a new state 
 value.</param>        
 <param name="initial">The initial state value.</param>
 <param name="axis">The axis to fold over.</param>
 <param name="a">The source tensor.</param>
 <returns>The output tensor containg the final states.</returns>
 <seealso cref="FillFoldAxis``2"/><seealso cref="HostTensor.Parallel.foldAxis``2"/>
</member>
<member name="M:Tensor.HostTensor.FillFoldAxis``2(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Tensor.Tensor{``0},System.Int32,Tensor.Tensor{``1})">
 <summary>Applies to specified function to all elements of the tensor, threading an accumulator through the 
 computation.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The output tensor that will contain the final state values.</param>
 <param name="fn">A function that takes a state value and a value from the input tensor and returns a new state 
 value.</param>        
 <param name="initial">The initial state value.</param>
 <param name="axis">The axis to fold over.</param>
 <param name="a">The source tensor.</param>
 <seealso cref="foldAxis``2"/><seealso cref="HostTensor.Parallel.FillFoldAxis``3"/>
</member>
<member name="M:Tensor.HostTensor.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int64[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},Tensor.Tensor{``0},Tensor.Tensor{``1})">
 <summary>Applies to specified indexed function to all elements of the two tensors.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="fn">A function that takes an index, the corresponding value from the first input and second input 
 tensor and returns the corresponding output value.</param>        
 <param name="a">The first input tensor.</param>
 <param name="b">The second input tensor.</param>
 <returns>The output tensor.</returns>
 <seealso cref="FillMapIndexed2``3"/><seealso cref="map2``3"/><seealso cref="HostTensor.Parallel.mapi2``3"/>
</member>
<member name="M:Tensor.HostTensor.FillMapIndexed2``3(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int64[],Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},Tensor.Tensor{``1},Tensor.Tensor{``2})">
 <summary>Applies to specified indexed function to all elements of the two tensors using the specified tensor as 
 target.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The output tensor to fill.</param>
 <param name="fn">A function that takes an index, the corresponding value from the first input and second input 
 tensor and returns the corresponding output value.</param>        
 <param name="a">The first input tensor.</param>
 <param name="b">The second input tensor.</param>
 <seealso cref="mapi2``3"/><seealso cref="HostTensor.Parallel.FillMapIndexed2``3"/>
</member>
<member name="M:Tensor.HostTensor.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Tensor.Tensor{``0},Tensor.Tensor{``1})">
 <summary>Applies to specified function to all elements of the two tensors.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="fn">A function that takes a value from the first input tensor and a value from the second input 
 tensor and returns the corresponding output value.</param>        
 <param name="a">The first input tensor.</param>
 <param name="b">The second input tensor.</param>
 <returns>The output tensor.</returns>
 <seealso cref="FillMap2``3"/><seealso cref="map``2"/><seealso cref="mapi2``3"/>
 <seealso cref="HostTensor.Parallel.map2``3"/>
</member>
<member name="M:Tensor.HostTensor.FillMap2``3(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}},Tensor.Tensor{``1},Tensor.Tensor{``2})">
 <summary>Applies to specified function to all elements of the two tensors using the specified tensor as 
 target.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The output tensor to fill.</param>
 <param name="fn">A function that takes a value from the first input tensor and a value from the second input 
 tensor and returns the corresponding output value.</param>        
 <param name="a">The first input tensor.</param>
 <param name="b">The second input tensor.</param>
 <seealso cref="map2``3"/><seealso cref="HostTensor.Parallel.FillMap2``3"/>
</member>
<member name="M:Tensor.HostTensor.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64[],Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Tensor.Tensor{``0})">
 <summary>Applies to specified indexed function to all elements of the tensor.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="fn">A function that takes an index and the corresponding value from the input tensor and returns 
 the corresponding output value.</param>        
 <param name="a">The source tensor.</param>
 <returns>The output tensor.</returns>
 <seealso cref="FillMapIndexed``2"/><seealso cref="map``2"/><seealso cref="HostTensor.Parallel.map``2"/>
</member>
<member name="M:Tensor.HostTensor.FillMapIndexed``2(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int64[],Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Tensor.Tensor{``1})">
 <summary>Applies to specified indexed function to all elements of the tensor using the specified tensor as 
 target.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The output tensor to fill.</param>
 <param name="fn">A function that takes an index and the corresponding value from the input tensor and returns 
 the corresponding output value.</param>        
 <param name="a">The input tensor.</param>
 <seealso cref="mapi``2"/><seealso cref="HostTensor.Parallel.FillMapIndexed``2"/>
</member>
<member name="M:Tensor.HostTensor.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Tensor.Tensor{``0})">
 <summary>Applies to specified function to all elements of the tensor.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="fn">A function that takes a value from the input tensor and returns the corresponding output 
 value.</param>        
 <param name="a">The source tensor.</param>
 <returns>The output tensor.</returns>
 <seealso cref="FillMap``2"/><seealso cref="mapi``2"/><seealso cref="map2``3"/>
 <seealso cref="HostTensor.Parallel.map``2"/>
</member>
<member name="M:Tensor.HostTensor.FillMap``2(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{``1,``0},Tensor.Tensor{``1})">
 <summary>Applies to specified function to all elements of the tensor using the specified tensor as 
 target.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The output tensor to fill.</param>
 <param name="fn">A function that takes a value from the input tensor and returns the corresponding output 
 value.</param>        
 <param name="a">The input tensor.</param>
 <seealso cref="map``2"/><seealso cref="HostTensor.Parallel.FillMap``2"/>
</member>
<member name="M:Tensor.HostTensor.FillSeq``1(Tensor.Tensor{``0},System.Collections.Generic.IEnumerable{``0})">
 <summary>Fills the tensor with the values returned by the given sequence.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The target tensor to fill.</param>
 <param name="data">The sequence of data to fill the tensor with.</param>    
</member>
<member name="M:Tensor.HostTensor.Fill``1(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>Fills the tensor with the values returned by the function.</summary>
 <param name="trgt">The target tensor to fill.</param>
 <param name="fn">A function that returns the values to fill the tensor with.</param>
 <seealso cref="HostTensor.Parallel.Fill``1"/>
</member>
<member name="M:Tensor.HostTensor.randomNormal``1(System.Random,``0,``0,Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a tensor filled with random numbers from a normale distribution.</summary>
 <param name="rnd">The random generator to use.</param>
 <param name="mean">The mean of the normal distribution.</param>
 <param name="variance">The variance of the normal distribution.</param>
 <param name="shp">The shape of the new tensor.</param>
 <returns>A tensor of specified shape filled with random numbers.</returns>
</member>
<member name="M:Tensor.HostTensor.randomUniform``1(System.Random,``0,``0,Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a tensor filled with random floating-point numbers from a uniform distribution.</summary>
 <param name="rnd">The random generator to use.</param>
 <param name="minValue">The minimum value.</param>
 <param name="maxValue">The maximum value.</param>
 <param name="shp">The shape of the new tensor.</param>
 <returns>A tensor of specified shape filled with random numbers.</returns>
</member>
<member name="M:Tensor.HostTensor.randomInt(System.Random,System.Int32,System.Int32,Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a tensor filled with random integer numbers from a uniform distribution.</summary>
 <param name="rnd">The random generator to use.</param>
 <param name="minValue">The minimum value.</param>
 <param name="maxValue">The maximum value.</param>
 <param name="shp">The shape of the new tensor.</param>
 <returns>A tensor of specified shape filled with random numbers.</returns>
</member>
<member name="M:Tensor.HostTensor.readUntyped(Tensor.HDF5,System.String)">
 <summary>Reads a tensor with unspecified data type from the specified HDF5 object path in an HDF5 file.</summary>
 <param name="hdf5">The HDF5 file.</param>
 <param name="path">The HDF5 object path.</param>
 <returns>A tensor filled with data read from the HDF5 file.</returns>
 <seealso cref="read``1"/>
</member>
<member name="M:Tensor.HostTensor.read``1(Tensor.HDF5,System.String)">
 <summary>Reads a tensor from the specified HDF5 object path in an HDF5 file.</summary>
 <typeparam name="'T">The type of the data. This must match the type of the data stored in the
 HDF5 file.</typeparam>
 <param name="hdf5">The HDF5 file.</param>
 <param name="path">The HDF5 object path.</param>
 <returns>A tensor filled with data read from the HDF5 file.</returns>
 <exception cref="System.InvalidOperationException">The data type stored in the HDF5 does 
 not match type <c>'T</c>.</exception>
 <example><code language="fsharp">
 use hdfFile = HDF5.OpenRead "tensors.h5"
 let k = HostTensor.read&lt;float&gt; hdfFile "k"
 </code></example>    
 <seealso cref="write"/><seealso cref="readUntyped"/>
</member>
<member name="M:Tensor.HostTensor.write(Tensor.HDF5,System.String,Tensor.ITensor)">
 <summary>Writes the tensor into the HDF5 file under the specfied HDF5 object path.</summary>
 <param name="hdf5">The HDF5 file.</param>
 <param name="path">The HDF5 object path.</param>
 <param name="x">The tensor to write.</param>
 <example><code language="fsharp">
 let k = HostTensor.init [5L; 3L] (fun [|i; j|] -> 3.0 * float i + float j)
 use hdfFile = HDF5.OpenWrite "tensors.h5"
 HostTensor.write hdfFile "k" k
 </code></example>    
</member>
<member name="M:Tensor.HostTensor.toList2D``1(Tensor.Tensor{``0})">
 <summary>Creates a list of lists from a two-dimensional tensor.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="a">The tensor to operate on.</param>
 <returns>A list of lists containing the values from the tensor.</returns>
 <remarks>The data is copied.</remarks>
 <seealso cref="toList``1"/><seealso cref="ofList2D``1"/>
</member>
<member name="M:Tensor.HostTensor.toList``1(Tensor.Tensor{``0})">
 <summary>Creates a list from a one-dimensional tensor.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="a">The tensor to operate on.</param>
 <returns>A list containing the values from the tensor.</returns>
 <remarks>The data is copied.</remarks>
 <seealso cref="toList2D``1"/><seealso cref="ofList``1"/>
</member>
<member name="M:Tensor.HostTensor.toArray4D``1(Tensor.Tensor{``0})">
 <summary>Creates an array from a four-dimensional tensor.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="a">The tensor to operate on.</param>
 <returns>An array containing the values from the tensor.</returns>
 <remarks>The data is copied.</remarks>
 <seealso cref="toArray``1"/><seealso cref="toArray2D``1"/><seealso cref="toArray3D``1"/>
 <seealso cref="ofArray4D``1"/>
</member>
<member name="M:Tensor.HostTensor.toArray3D``1(Tensor.Tensor{``0})">
 <summary>Creates an array from a three-dimensional tensor.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="a">The tensor to operate on.</param>
 <returns>An array containing the values from the tensor.</returns>
 <remarks>The data is copied.</remarks>
 <seealso cref="toArray``1"/><seealso cref="toArray2D``1"/><seealso cref="toArray4D``1"/>
 <seealso cref="ofArray3D``1"/>
</member>
<member name="M:Tensor.HostTensor.toArray2D``1(Tensor.Tensor{``0})">
 <summary>Creates an array from a two-dimensional tensor.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="a">The tensor to operate on.</param>
 <returns>An array containing the values from the tensor.</returns>
 <remarks>The data is copied.</remarks>
 <seealso cref="toArray``1"/><seealso cref="toArray2D``1"/><seealso cref="toArray3D``1"/>
 <seealso cref="ofArray2D``1"/>
</member>
<member name="M:Tensor.HostTensor.toArray``1(Tensor.Tensor{``0})">
 <summary>Creates an array from a one-dimensional tensor.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="a">The tensor to operate on.</param>
 <returns>An array containing the values from the tensor.</returns>
 <remarks>The data is copied.</remarks>
 <seealso cref="toArray2D``1"/><seealso cref="toArray3D``1"/><seealso cref="toArray4D``1"/>
 <seealso cref="ofArray``1"/>
</member>
<member name="M:Tensor.HostTensor.ofList2D``1(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Collections.FSharpList{``0}})">
 <summary>Creates a two-dimensional tensor from the specified list of lists.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="data">The data to fill the tensor with.</param>
 <returns>A tensor containing values from the specifed lists.</returns>
 <seealso cref="ofSeq``1"/><seealso cref="ofList``1"/>    
 <seealso cref="toList2D``1"/>
</member>
<member name="M:Tensor.HostTensor.ofList``1(Microsoft.FSharp.Collections.FSharpList{``0})">
 <summary>Creates a one-dimensional tensor from the specified list.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="data">The data to fill the tensor with.</param>
 <returns>A tensor containing values from the specifed list.</returns>
 <seealso cref="ofSeq``1"/><seealso cref="ofList2D``1"/>    
 <seealso cref="toList``1"/>
</member>
<member name="M:Tensor.HostTensor.toSeq``1(Tensor.Tensor{``0})">
 <summary>A sequence of all elements contained in the tensor.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="a">The tensor to operate on.</param>
 <returns>A sequence of all elements of the tensor.</returns>
 <remarks>The enumeration is done so that the last index is the fastest changing index.</remarks>
 <seealso cref="ofSeq``1"/>
</member>
<member name="M:Tensor.HostTensor.ofSeqWithShape``1(Microsoft.FSharp.Collections.FSharpList{System.Int64},System.Collections.Generic.IEnumerable{``0})">
 <summary>Creates a one-dimensional Tensor using the specified sequence and shape.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="shape">The shape of the new tensor.</param>
 <param name="data">The data to fill the tensor with.</param>
 <returns>A tensor containing values from the specifed sequence.</returns>
 <remarks>Only the number of elements required to fill the tensor of the specified
 shape are consumed from the sequence. Thus it may be infinite.</remarks>
 <seealso cref="ofSeq``1"/>
</member>
<member name="M:Tensor.HostTensor.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>Creates a one-dimensional tensor from the specified sequence.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="data">The data to fill the tensor with.</param>
 <returns>A tensor containing values from the specifed sequence.</returns>
 <remarks>The sequence must be finite.</remarks>
 <seealso cref="ofSeqWithShape``1"/><seealso cref="ofList``1"/> 
</member>
<member name="M:Tensor.HostTensor.ofArray4D``1(``0[0:, 0:, 0:, 0:])">
 <summary>Creates a four-dimensional tensor copying the specified data.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="data">The data array to use.</param>
 <returns>A tensor using filled with the values from <c>data</c>.</returns>
 <remarks>The data is copied.</remarks>
 <seealso cref="ofArray``1"/><seealso cref="ofArray2D``1"/><seealso cref="ofArray3D``1"/>
</member>
<member name="M:Tensor.HostTensor.ofArray3D``1(``0[0:, 0:, 0:])">
 <summary>Creates a three-dimensional tensor copying the specified data.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="data">The data array to use.</param>
 <returns>A tensor using filled with the values from <c>data</c>.</returns>
 <remarks>The data is copied.</remarks>
 <seealso cref="ofArray``1"/><seealso cref="ofArray2D``1"/><seealso cref="ofArray4D``1"/>
</member>
<member name="M:Tensor.HostTensor.ofArray2D``1(``0[0:, 0:])">
 <summary>Creates a two-dimensional tensor copying the specified data.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="data">The data array to use.</param>
 <returns>A tensor using filled with the values from <c>data</c>.</returns>
 <remarks>The data is copied.</remarks>
 <seealso cref="ofArray``1"/><seealso cref="ofArray3D``1"/><seealso cref="ofArray4D``1"/>
</member>
<member name="M:Tensor.HostTensor.ofArray``1(``0[])">
 <summary>Creates a one-dimensional tensor copying the specified data.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="data">The data array to use.</param>
 <returns>A tensor filled with the values from <c>data</c>.</returns>
 <remarks>The data is copied.</remarks>
 <seealso cref="usingArray``1"/>
 <seealso cref="ofArray2D``1"/><seealso cref="ofArray3D``1"/><seealso cref="ofArray4D``1"/>
</member>
<member name="M:Tensor.HostTensor.usingArray``1(``0[])">
 <summary>Creates a one-dimensional tensor referencing the specified data.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="data">The data array to use.</param>
 <returns>A tensor using the array <c>data</c> as its storage.</returns>
 <remarks>The data array is referenced, not copied.
 Thus changing the tensor modifies the specified data array and vice versa.</remarks>
 <seealso cref="ofArray``1"/>
</member>
<member name="M:Tensor.HostTensor.linspace``1(``0,``0,System.Int64)">
 <summary>Creates a new vector of given size filled with equaly spaced values.</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>
 <param name="start">The starting value.</param>
 <param name="stop">The end value, which is not included.</param>
 <param name="nElems">The size of the vector.</param>   
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.linspace``2"/>
</member>
<member name="M:Tensor.HostTensor.arange``1(``0,``0,``0)">
 <summary>Creates a new vector filled with equaly spaced values using a specifed increment.</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>
 <param name="start">The starting value.</param>
 <param name="incr">The increment between successive element.</param>   
 <param name="stop">The end value, which is not included.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.arange``3"/>
</member>
<member name="M:Tensor.HostTensor.counting(System.Int64)">
 <summary>Creates a new vector filled with the integers from zero to the specified maximum.</summary>
 <param name="nElems">The number of elements of the new vector.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.counting"/>
</member>
<member name="M:Tensor.HostTensor.identity``1(System.Int64)">
 <summary>Creates a new identity matrix.</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>
 <param name="size">The size of the square identity matrix.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.identity"/>
</member>
<member name="M:Tensor.HostTensor.filled``1(Microsoft.FSharp.Collections.FSharpList{System.Int64},``0)">
 <summary>Creates a new tensor filled with the specified value.</summary>
 <param name="shape">The shape of the new tensor.</param>
 <param name="value">The value to fill the new tensor with.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.filled"/>
</member>
<member name="M:Tensor.HostTensor.scalar``1(``0)">
 <summary>Creates a new zero-dimensional (scalar) tensor with the specified value.</summary>
 <param name="value">The value of the new, scalar tensor.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.scalar"/>
</member>
<member name="M:Tensor.HostTensor.trues(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new boolean tensor filled with trues.</summary>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.trues"/>
</member>
<member name="M:Tensor.HostTensor.falses(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new boolean tensor filled with falses.</summary>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.falses"/>
</member>
<member name="M:Tensor.HostTensor.ones``1(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new tensor filled with ones (1).</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.ones"/>
</member>
<member name="M:Tensor.HostTensor.zeros``1(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new tensor filled with zeros (0).</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.zeros"/>
</member>
<member name="M:Tensor.HostTensor.empty``1(System.Int32)">
 <summary>Creates a new, empty tensor with the given number of dimensions.</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>    
 <param name="nDims">The number of dimensions of the new, empty tensor.</param>
 <returns>The new tensor.</returns>    
 <seealso cref="Tensor`1.empty"/>
</member>
<member name="M:Tensor.HostTensor.transfer``1(Tensor.Tensor{``0})">
 <summary>Transfers a tensor to the host device.</summary>
 <typeparam name="'T">The data type of the tensor.</typeparam>    
 <param name="a">The tensor to transfer.</param>
 <returns>A tensor on the host device.</returns>
 <seealso cref="Tensor`1.transfer"/>
</member>
<member name="M:Tensor.HostTensor.init``1(Microsoft.FSharp.Collections.FSharpList{System.Int64},Microsoft.FSharp.Core.FSharpFunc{System.Int64[],``0})">
 <summary>Creates a new tensor with values returned by the specified function.</summary>
 <param name="shape">The shape of the new tensor.</param>
 <param name="fn">A function that takes the index of the element to fill and returns
 the corresponding value.</param>
 <seealso cref="FillIndexed``1"/><seealso cref="HostTensor.Parallel.init``1"/>  
</member>
<member name="M:Tensor.HostTensor.FillIndexed``1(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int64[],``0})">
 <summary>Fills the tensor with values returned by the specifed function.</summary>
 <param name="trgt">The target tensor to fill.</param>
 <param name="fn">A function that takes the index of the element to fill and returns
 the corresponding value.</param>
 <seealso cref="init``1"/><seealso cref="HostTensor.Parallel.FillIndexed``1"/>      
</member>
<member name="M:Tensor.HostTensor.backend``1(Tensor.Tensor{``0})">
<summary>
 Gets the backend of a host tensor.
</summary>
</member>
<member name="P:Tensor.HostTensor.Dev">
 <summary>Tensor device using a .NET array in host memory as data storage.</summary>
 <seealso cref="Tensor`1.Dev"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.foldAxis``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Int32,Tensor.Tensor{``1})">
 <summary>Applies to specified function to all elements of the tensor, threading an accumulator through 
 the computation using multiple threads.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="fn">A function that takes a state value and a value from the input tensor and returns a new 
 state value.</param>        
 <param name="initial">The initial state value.</param>
 <param name="axis">The axis to fold over.</param>
 <param name="a">The source tensor.</param>
 <returns>The output tensor containg the final states.</returns>
 <seealso cref="HostTensor.foldAxis``2"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.mapi2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int64[],Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},Tensor.Tensor{``0},Tensor.Tensor{``1})">
 <summary>Applies to specified indexed function to all elements of the two tensors using multiple 
 threads.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="fn">A function that takes an index, the corresponding value from the first input and second 
 input tensor and returns the corresponding output value.</param>        
 <param name="a">The first input tensor.</param>
 <param name="b">The second input tensor.</param>
 <returns>The output tensor.</returns>
 <seealso cref="HostTensor.mapi2``3"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Tensor.Tensor{``0},Tensor.Tensor{``1})">
 <summary>Applies to specified function to all elements of the two tensors using multiple threads.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="fn">A function that takes a value from the first input tensor and a value from the second input 
 tensor and returns the corresponding output value.</param>        
 <param name="a">The first input tensor.</param>
 <param name="b">The second input tensor.</param>
 <returns>The output tensor.</returns>
 <seealso cref="HostTensor.map2``3"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.mapi``2(Microsoft.FSharp.Core.FSharpFunc{System.Int64[],Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Tensor.Tensor{``0})">
 <summary>Applies to specified indexed function to all elements of the tensor using multiple threads.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="fn">A function that takes an index and the corresponding value from the input tensor and returns 
 the corresponding output value.</param>        
 <param name="a">The source tensor.</param>
 <returns>The output tensor.</returns>
 <seealso cref="HostTensor.map``2"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Tensor.Tensor{``0})">
 <summary>Applies to specified function to all elements of the tensor using multiple threads.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="fn">A function that takes a value from the input tensor and returns the corresponding output 
 value.</param>        
 <param name="a">The source tensor.</param>
 <returns>The output tensor.</returns>
 <seealso cref="HostTensor.map``2"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.init``1(Microsoft.FSharp.Collections.FSharpList{System.Int64},Microsoft.FSharp.Core.FSharpFunc{System.Int64[],``0})">
 <summary>Creates a new tensor with values returned by the specified function using multiple threads.</summary>
 <param name="shape">The shape of the new tensor.</param>
 <param name="fn">A function that takes the index of the element to fill and returns
 the corresponding value.</param>
 <seealso cref="HostTensor.FillIndexed``1"/>      
</member>
<member name="M:Tensor.HostTensor.Parallel.FillFoldAxis``2(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Tensor.Tensor{``0},System.Int32,Tensor.Tensor{``1})">
 <summary>Applies to specified function to all elements of the tensor, threading an accumulator through the 
 computation using multiple threads.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The output tensor that will contain the final state values.</param>
 <param name="fn">A function that takes a state value and a value from the input tensor and returns a new 
 state value.</param>        
 <param name="initial">The initial state value.</param>
 <param name="axis">The axis to fold over.</param>
 <param name="a">The source tensor.</param>
 <seealso cref="HostTensor.FillFoldAxis``3"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.FillMapIndexed2``3(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int64[],Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}}},Tensor.Tensor{``1},Tensor.Tensor{``2})">
 <summary>Applies to specified indexed function to all elements of the two tensors using the specified tensor 
 as target using multiple threads.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The output tensor to fill.</param>
 <param name="fn">A function that takes an index, the corresponding value from the first input and second input 
 tensor and returns the corresponding output value.</param>        
 <param name="a">The first input tensor.</param>
 <param name="b">The second input tensor.</param>
 <seealso cref="HostTensor.FillMapIndexed2``3"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.FillMap2``3(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``0}},Tensor.Tensor{``1},Tensor.Tensor{``2})">
 <summary>Applies to specified function to all elements of the two tensors using the specified tensor as 
 target using multiple threads.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The output tensor to fill.</param>
 <param name="fn">A function that takes a value from the first input tensor and a value from the second input 
 tensor and returns the corresponding output value.</param>        
 <param name="a">The first input tensor.</param>
 <param name="b">The second input tensor.</param>
 <seealso cref="HostTensor.FillMap2``3"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.FillMapIndexed``2(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int64[],Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Tensor.Tensor{``1})">
 <summary>Applies to specified indexed function to all elements of the tensor using the specified tensor as 
 target using multiple threads.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The output tensor to fill.</param>
 <param name="fn">A function that takes an index and the corresponding value from the input tensor and returns 
 the corresponding output value.</param>        
 <param name="a">The input tensor.</param>
 <seealso cref="HostTensor.FillMapIndexed``2"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.FillMap``2(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{``1,``0},Tensor.Tensor{``1})">
 <summary>Applies to specified function to all elements of the tensor using the specified tensor as target 
 using multiple threads.</summary>
 <typeparam name="'T">The type of the data.</typeparam>
 <param name="trgt">The output tensor to fill.</param>
 <param name="fn">A function that takes a value from the input tensor and returns the corresponding output 
 value.</param>        
 <param name="a">The input tensor.</param>
 <seealso cref="HostTensor.FillMap``2"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.Fill``1(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
 <summary>Fills the tensor with the values returned by the function using multiple threads.</summary>
 <param name="trgt">The target tensor to fill.</param>
 <param name="fn">A function that returns the values to fill the tensor with.</param>
 <seealso cref="HostTensor.Fill``1"/>
</member>
<member name="M:Tensor.HostTensor.Parallel.FillIndexed``1(Tensor.Tensor{``0},Microsoft.FSharp.Core.FSharpFunc{System.Int64[],``0})">
 <summary>Fills the tensor with values returned by the specifed function using multiple threads.</summary>
 <param name="trgt">The target tensor to fill.</param>
 <param name="fn">A function that takes the index of the element to fill and returns
 the corresponding value.</param>
 <seealso cref="HostTensor.FillIndexed``1"/> 
</member>
<member name="T:Tensor.HostTensor.Parallel">
 <summary>Multi-threaded operations for tensors stored on the host device.</summary>
 <seealso cref="HostTensor"/>
</member>
<member name="T:Tensor.HostTensor">
 <summary>Functions for creating and operating on tensors stored in host memory.</summary>
 <remarks>This module contains functions for creating tensors stored in host memory.
 It further contains functions that only work with tensors stored in host memory.
 Calling these functions with tensors stored on other devices will result in an
 <see cref="System.InvalidOperationException"/>.</remarks>
 <example><code language="fsharp">
 let x = HostTensor.zeros [3L; 3L]  // x.Dev = HostTensor.Dev
 </code></example>
 <seealso cref="Tensor`1"/><seealso cref="HostTensor.Parallel"/>
</member>
<member name="P:Tensor.Cuda.Cfg.Stream(ManagedCuda.BasicTypes.CUstream)">
 <summary>The CUDA stream to execute CUDA operations on.</summary>
 <remarks>This setting is local to the calling thread and defaults to the null stream.</remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.Stacktrace(System.Boolean)">
 <summary>If set to true, CUDA operations produce an acurate stack trace when an error is encountered.</summary>
 <remarks>
 <para>Setting this to <c>true</c> affects performance, even if no error occurs.</para>
 <para>This setting is local to the calling thread and defaults to <c>false</c>.</para>
 </remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.RestrictKernels(System.Boolean)">
 <summary>If set to true, all arguments are passed as restriced to CUDA kernels (experimental).</summary>
 <remarks>This setting is local to the calling thread and defaults to <c>false</c>.</remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.FastKernelMath(System.Boolean)">
 <summary>If set to true, CUDA uses fast math functions with lower accuracy.</summary>
 <remarks>This setting is local to the calling thread and defaults to <c>false</c>.</remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.DisableKernelCache(System.Boolean)">
 <summary>If set to true, the CUDA kernel cache is disabled.</summary>
 <remarks>This setting is local to the calling thread and defaults to <c>false</c>.</remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.DebugCompile(System.Boolean)">
 <summary>If set to true, all CUDA kernels are compiled with debug flags.</summary>
 <remarks>This setting is local to the calling thread and defaults to <c>false</c>.</remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.Stream">
 <summary>The CUDA stream to execute CUDA operations on.</summary>
 <remarks>This setting is local to the calling thread and defaults to the null stream.</remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.Stacktrace">
 <summary>If set to true, CUDA operations produce an acurate stack trace when an error is encountered.</summary>
 <remarks>
 <para>Setting this to <c>true</c> affects performance, even if no error occurs.</para>
 <para>This setting is local to the calling thread and defaults to <c>false</c>.</para>
 </remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.RestrictKernels">
 <summary>If set to true, all arguments are passed as restriced to CUDA kernels (experimental).</summary>
 <remarks>This setting is local to the calling thread and defaults to <c>false</c>.</remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.FastKernelMath">
 <summary>If set to true, CUDA uses fast math functions with lower accuracy.</summary>
 <remarks>This setting is local to the calling thread and defaults to <c>false</c>.</remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.DisableKernelCache">
 <summary>If set to true, the CUDA kernel cache is disabled.</summary>
 <remarks>This setting is local to the calling thread and defaults to <c>false</c>.</remarks>
</member>
<member name="P:Tensor.Cuda.Cfg.DebugCompile">
 <summary>If set to true, all CUDA kernels are compiled with debug flags.</summary>
 <remarks>This setting is local to the calling thread and defaults to <c>false</c>.</remarks>
</member>
<member name="T:Tensor.Cuda.Cfg">
 <summary>Options for configuring operations performed on CUDA tensors.</summary>
 <remarks>All settings are local to the calling thread.</remarks>
 <seealso cref="CudaTensor"/>
</member>
<member name="P:Tensor.Cuda.CudaRegMemHnd.Ptr">
<summary>
 pointer to data 
</summary>
</member>
<member name="P:Tensor.Cuda.CudaRegMemHnd.PinHnd">
<summary>
 GC memory pin handle
</summary>
</member>
<member name="P:Tensor.Cuda.CudaRegMemHnd.HostArray">
<summary>
 the data array
</summary>
</member>
<member name="P:Tensor.Cuda.CudaRegMemHnd.CudaRegisteredMemory">
<summary>
 the CudaRegisteredHostMemory
</summary>
</member>
<member name="T:Tensor.Cuda.CudaRegMemHnd">
<summary>
 CUDA registered memory for fast data transfer.
 Dispose to unregister memory with CUDA.
</summary>
</member>
<member name="T:Tensor.Cuda.NativeIdxTensorsInfo">
<summary>
 C++ NativeIdx template info
</summary>
</member>
<member name="T:Tensor.Cuda.NativeIdxTensors">
<summary>
 C++ NativeIdx 
</summary>
</member>
<member name="T:Tensor.Cuda.NativeTensorInfo">
<summary>
 C++ tensor marshaling
</summary>
</member>
<member name="T:Tensor.Cuda.NativeTensor">
<summary>
 C++ tensor marshaling
</summary>
</member>
<member name="T:Tensor.Cuda.CudaModule">
<summary>
 A CUDA module built from source containing kernel functions.
</summary>
</member>
<member name="T:Tensor.Cuda.KernelArgType">
<summary>
 Argument type of a CUDA kernel
</summary>
</member>
<member name="T:Tensor.Cuda.ModCacheKey">
<summary>
 CUDA module caching key.
</summary>
</member>
<member name="T:Tensor.Cuda.TensorKernels">
<summary>
 CUDA kernels for the CUDA tensor backend
</summary>
</member>
<member name="T:Tensor.Cuda.TensorCudaDevice">
<summary>
 Creates Tensors on a CUDA device.
</summary>
</member>
<member name="P:Tensor.Cuda.TensorCudaBackend`1.NativeTensor">
<summary>
 tensor information for native CUDA code
</summary>
</member>
<member name="P:Tensor.Cuda.TensorCudaBackend`1.DevicePtr">
<summary>
 device pointer to first element of this tensor
</summary>
</member>
<member name="M:Tensor.Cuda.TensorCudaBackend`1.GetNativeTensor``1(Tensor.Backend.ITensorFrontend{`0},Tensor.Backend.ITensorFrontend{``0})">
<summary>
 gets NativeTensors for specified tensors
</summary>
</member>
<member name="M:Tensor.Cuda.TensorCudaBackend`1.GetNativeTensor(Tensor.Backend.ITensorFrontend{`0})">
<summary>
 gets NativeTensors for specified tensors
</summary>
</member>
<member name="M:Tensor.Cuda.TensorCudaBackend`1.ElemwiseNativeTensor``4(Tensor.Backend.ITensorFrontend{`0},Tensor.Backend.ITensorFrontend{``1},Tensor.Backend.ITensorFrontend{``2},Tensor.Backend.ITensorFrontend{``3})">
<summary>
 gets NativeTensors for specified tensors, optimized for elment-wise operations
</summary>
</member>
<member name="M:Tensor.Cuda.TensorCudaBackend`1.ElemwiseNativeTensor``3(Tensor.Backend.ITensorFrontend{`0},Tensor.Backend.ITensorFrontend{``1},Tensor.Backend.ITensorFrontend{``2})">
<summary>
 gets NativeTensors for specified tensors, optimized for elment-wise operations
</summary>
</member>
<member name="M:Tensor.Cuda.TensorCudaBackend`1.ElemwiseNativeTensor``2(Tensor.Backend.ITensorFrontend{`0},Tensor.Backend.ITensorFrontend{``1})">
<summary>
 gets NativeTensors for specified tensors, optimized for elment-wise operations
</summary>
</member>
<member name="M:Tensor.Cuda.TensorCudaBackend`1.ElemwiseNativeTensor``1(Tensor.Backend.ITensorFrontend{`0})">
<summary>
 gets NativeTensors for specified tensors, optimized for elment-wise operations
</summary>
</member>
<member name="T:Tensor.Cuda.TensorCudaBackend`1">
<summary>
 CUDA backend for tensors.
</summary>
</member>
<member name="T:Tensor.Cuda.ITensorCudaBackend">
<summary>
 type-neutral interface to CUDA backend for tensors
</summary>
</member>
<member name="P:Tensor.Cuda.TensorCudaStorage`1.Item(System.Int64,`0)">
<summary>
 data item access
</summary>
</member>
<member name="P:Tensor.Cuda.TensorCudaStorage`1.Item(System.Int64)">
<summary>
 data item access
</summary>
</member>
<member name="P:Tensor.Cuda.TensorCudaStorage`1.DataSizeInBytes">
<summary>
 data size in bytes
</summary>
</member>
<member name="P:Tensor.Cuda.TensorCudaStorage`1.DataSize">
<summary>
 data size in elements
</summary>
</member>
<member name="P:Tensor.Cuda.TensorCudaStorage`1.Data">
<summary>
 data device variable
</summary>
</member>
<member name="P:Tensor.Cuda.TensorCudaStorage`1.ByteData">
<summary>
 data device variable as CudaDeviceVariable&lt;byte&gt;
</summary>
</member>
<member name="T:Tensor.Cuda.TensorCudaStorage`1">
<summary>
 Tensor storage on a CUDA device.
</summary>
</member>
<member name="T:Tensor.Cuda.ITensorCudaStorage">
<summary>
 type neutral interface to a CudaStorageT
</summary>
</member>
<member name="T:Tensor.Cuda.OutOfCudaMemoryException">
<summary>
 Out of CUDA memory.
</summary>
</member>
<member name="T:Tensor.Cuda.CannotCudaRegisterMemoryException">
<summary>
 Cannot register host memory with CUDA, maybe because it is not properly aligned.
</summary>
</member>
<member name="T:Tensor.Cuda.Cuda.LaunchDim">
<summary>
 CUDA launch dimension
</summary>
</member>
<member name="T:Tensor.Cuda.Cuda.GridDim">
<summary>
 CUDA grid dimension (x, y, z)
</summary>
</member>
<member name="T:Tensor.Cuda.Cuda.BlockDim">
<summary>
 CUDA block dimension (x, y, z)
</summary>
</member>
<member name="T:Tensor.Cuda.Cuda.WorkDim">
<summary>
 dimensionality of parallel work to perform (x, y, z)
</summary>
</member>
<member name="M:Tensor.Cuda.Cuda.tryObtainMem(System.Int64,System.Int32)">
<summary>
 tries to obtain neededMem bytes of CUDA memory by invoking the GC if necessary
</summary>
</member>
<member name="P:Tensor.Cuda.Cuda.minAvailMem">
<summary>
 minimum available CUDA memory before triggering GC
</summary>
</member>
<member name="M:Tensor.Cuda.Cuda.keepAliveMany(ManagedCuda.BasicTypes.CUstream,Microsoft.FSharp.Collections.FSharpList{System.Object})">
<summary>
 Keeps the given objects alive (i.e. prevent them from being GCed) 
 until all operations that were queued on the given CUDA stream 
 up to now have been executed.
</summary>
</member>
<member name="M:Tensor.Cuda.Cuda.keepAlive(ManagedCuda.BasicTypes.CUstream,System.Object)">
<summary>
 Keeps the given object alive (i.e. prevent it from being GCed) 
 until all operations that were queued on the given CUDA stream 
 up to now have been executed.
</summary>
</member>
<member name="M:Tensor.Cuda.Cuda.callbackWithResult(ManagedCuda.BasicTypes.CUstream,Microsoft.FSharp.Core.FSharpFunc{ManagedCuda.BasicTypes.CUResult,Microsoft.FSharp.Core.Unit})">
<summary>
 Places a callback function on a CUDA stream.
 The function is executed on a thread-pool thread and is allowed to make CUDA calls.
 This function is less efficient than Cuda.callback.
</summary>
</member>
<member name="M:Tensor.Cuda.Cuda.callback(ManagedCuda.BasicTypes.CUstream,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Places a callback function on a CUDA stream.
 The function is executed on a global callback thread and is allowed to make CUDA calls.
 The thread&apos;s CUDA context has been set to the libraries CUDA context.
 The CUDA stream continues execution while the callback function is being invoked.
 The callback can be blocked by waiting for other callbacks.
</summary>
</member>
<member name="M:Tensor.Cuda.Cuda.getIntPtr(ManagedCuda.BasicTypes.CUdeviceptr)">
<summary>
 gets device pointer as IntPtr
</summary>
</member>
<member name="M:Tensor.Cuda.Cuda.computeLaunchDim(System.Int64,System.Int64,System.Int64,System.Int32)">
<summary>
 Computes CUDA launch dimensions from work dimensions and maximum block size.
 It is possible that the calculated launch dimensions will be smaller than the
 specified work dimensions, since the maximum block and grid sizes are limited.
</summary>
</member>
<member name="M:Tensor.Cuda.Cuda.divCeil(System.Int64,System.Int64)">
<summary>
 Is equivalent to int64 (ceil(float a / float b)).
</summary>
</member>
<member name="M:Tensor.Cuda.Cuda.setContext">
<summary>
 Sets the thread&apos;s current CUDA context to the CUDA context that was active
 or created while this module was initialized.
</summary>
</member>
<member name="P:Tensor.Cuda.Cuda.nvccCode">
<summary>
 nvcc sm code
</summary>
</member>
<member name="P:Tensor.Cuda.Cuda.nvccArch">
<summary>
 nvcc arch code
</summary>
</member>
<member name="P:Tensor.Cuda.Cuda.maxGridDim">
<summary>
 CUDA maximum grid dimension
</summary>
</member>
<member name="P:Tensor.Cuda.Cuda.maxBlockDim">
<summary>
 CUDA maximum block dimension
</summary>
</member>
<member name="P:Tensor.Cuda.Cuda.deviceInfo">
<summary>
 CUDA device info
</summary>
</member>
<member name="P:Tensor.Cuda.Cuda.context">
<summary>
 CUDA context
</summary>
</member>
<member name="M:Tensor.Cuda.Cuda.toDim3(System.Int32,System.Int32,System.Int32)">
<summary>
 convert block/grid dimension (x, y, z) to VectorTypes.dim3
</summary>
</member>
<member name="T:Tensor.Cuda.Cuda">
<summary>
 Cuda support types functions
</summary>
</member>
<member name="M:Tensor.Cuda.CudaRegMem.register(Tensor.Host.ITensorHostStorage)">
<summary>
 registers a TensorHostStorage (multiple registrations are okay) and returns the corresponding CudaRegMemHnd
</summary>
</member>
<member name="M:Tensor.Cuda.CudaRegMem.getCudaRegisteredMemory(Tensor.Host.ITensorHostStorage)">
<summary>
 gets the CudaRegisteredMemory for already locked TensorHostStorage without 
 incrementing the reference count
</summary>
</member>
<member name="M:Tensor.Cuda.CudaRegMem.get(Tensor.Host.ITensorHostStorage)">
<summary>
 get CudaRegMemHnd for already locked TensorHostStorage          
</summary>
</member>
<member name="T:Tensor.Cuda.CudaRegMem">
<summary>
 Methods for locking a TensorHostStorage into memory and registering the memory with CUDA
 for fast data transfers with GPU device.
</summary>
</member>
<member name="M:Tensor.Cuda.CudaRegMemSupport.decrRefCount(Tensor.Host.ITensorHostStorage)">
<summary>
 decreases reference count for page locked data
</summary>
</member>
<member name="P:Tensor.Cuda.CudaRegMemSupport.dataRegistrations">
<summary>
 master data registrations
</summary>
</member>
<member name="P:Tensor.Cuda.CudaRegMemSupport.registeredCount">
<summary>
 registration count
</summary>
</member>
<member name="P:Tensor.Cuda.CudaRegMemSupport.syncLock">
<summary>
 synchronization lock
</summary>
</member>
<member name="T:Tensor.Cuda.CudaRegMemSupport">
<summary>
 CUDA registered memory support
</summary>
</member>
<member name="M:Tensor.Cuda.NativeIdxTensorsModule.mangledName(Tensor.Cuda.NativeIdxTensorsInfo)">
<summary>
 C++ mangled name
</summary>
</member>
<member name="M:Tensor.Cuda.NativeIdxTensorsModule.cppName(Tensor.Cuda.NativeIdxTensorsInfo)">
<summary>
 C++ type string
</summary>
</member>
<member name="M:Tensor.Cuda.NativeIdxTensorsModule.marshal(Tensor.Cuda.NativeIdxTensors)">
<summary>
 C++ IdxTensors&lt;nDims, nIdxs&gt; struct ready for marshalling
</summary>
</member>
<member name="T:Tensor.Cuda.NativeIdxTensorsModule">
<summary>
 C++ NativeIdx marshalling
</summary>
</member>
<member name="M:Tensor.Cuda.NativeTensorModule.cppName(Tensor.Cuda.NativeTensorInfo)">
<summary>
 C++ native tensor type string
</summary>
</member>
<member name="M:Tensor.Cuda.NativeTensorModule.marshal(Tensor.Cuda.NativeTensor)">
<summary>
 C++ Tensor&lt;T, nDims&gt; struct ready for marshaling
</summary>
</member>
<member name="T:Tensor.Cuda.NativeTensorModule">
<summary>
 C++ tensor marshaling
</summary>
</member>
<member name="T:Tensor.Cuda.DynamicTypes">
<summary>
 Dynamic type helpers.
</summary>
</member>
<member name="M:Tensor.Cuda.Cpp.cppType``1">
<summary>
 C++ data type for given type 
</summary>
</member>
<member name="M:Tensor.Cuda.Cpp.cppTypeInst(System.Type)">
<summary>
 C++ data type for given type instance
</summary>
</member>
<member name="T:Tensor.Cuda.Cpp">
<summary>
 C++ data type helpers
</summary>
</member>
<member name="M:Tensor.Cuda.KernelHelpers.workDimForElemwise(Tensor.Cuda.NativeTensor)">
<summary>
 returns the CUDA work dimensions (x, y, z) for an element-wise operation
</summary>
</member>
<member name="M:Tensor.Cuda.KernelHelpers.workDimForWorkSize(Microsoft.FSharp.Collections.FSharpList{System.Int64},System.Boolean)">
<summary>
 returns the CUDA work dimensions (x, y, z) for work of given size
</summary>
</member>
<member name="T:Tensor.Cuda.KernelArgTypeModule">
<summary>
 Argument type of a CUDA kernel
</summary>
</member>
<member name="M:Tensor.Cuda.KernelCompiler.unload(ManagedCuda.BasicTypes.CUmodule)">
<summary>
 unloads previously loaded CUDA kernel code
</summary>
</member>
<member name="M:Tensor.Cuda.KernelCompiler.load(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Compiles the given CUDA device code into a CUDA module, loads and jits it and returns
 ManagedCuda.CudaKernel objects for the specified kernel names.
</summary>
</member>
<member name="M:Tensor.Cuda.KernelCompiler.removeCompileDir(System.String)">
<summary>
 removes a compile directory
</summary>
</member>
<member name="M:Tensor.Cuda.KernelCompiler.prepareCompileDir(System.String)">
<summary>
 prepares a compile directory
</summary>
</member>
<member name="T:Tensor.Cuda.KernelCompiler">
<summary>
 compiles CUDA C++ code to CUDA kernels.
</summary>
</member>
<member name="M:Tensor.Cuda.CudaInit.check">
<summary>
 Checks if CUDA context access is possible.
 If not, a CudaError is thrown.
</summary>
</member>
<member name="P:Tensor.Cuda.CudaInit.initialized">
<summary>
 the CUDA context we are using
</summary>
</member>
<member name="T:Tensor.Cuda.CudaInit">
<summary>
 CUDA initialization helper.
 We check that CUDA context access is possible before calling other CUDA functions to avoid
 exceptions being thrown from static initializers.
</summary>
</member>
<member name="M:Tensor.CudaTensor.usingPtr``1(ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.SizeT,Tensor.Backend.TensorLayout)">
 <summary>Creates a tensor from the given CUDA pointer, allocation size in bytes and layout.</summary>
 <typeparam name="'T">Type of contained data.</typeparam>
 <param name="ptr">A CUDA device pointer.</param>
 <param name="sizeInBytes">Size of the allocation referenced by <paramref name="ptr"/> in bytes.</param>
 <param name="layout">Layout of the tensor.</param>
 <remarks>
 <p>This function creates a tensor using existing data in GPU memory.</p>
 <p>The data is referenced. Thus changing values within the tensor affects the original data.</p>
 </remarks>
</member>
<member name="M:Tensor.CudaTensor.usingPtrAndType(ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.SizeT,System.Type,Tensor.Backend.TensorLayout)">
 <summary>Creates a tensor from the given CUDA pointer, allocation size in bytes, type and layout.</summary>
 <param name="ptr">A CUDA device pointer.</param>
 <param name="sizeInBytes">Size of the allocation referenced by <paramref name="ptr"/> in bytes.</param>
 <param name="typ">Type of contained data.</param>
 <param name="layout">Layout of the tensor.</param>
 <remarks>
 <p>This function creates a tensor using existing data in GPU memory.</p>
 <p>The data is referenced. Thus changing values within the tensor affects the original data.</p>
 </remarks>
</member>
<member name="M:Tensor.CudaTensor.linspace``1(``0,``0,System.Int64)">
 <summary>Creates a new vector of given size filled with equaly spaced values.</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>
 <param name="start">The starting value.</param>
 <param name="stop">The end value, which is not included.</param>
 <param name="nElems">The size of the vector.</param>   
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.linspace``2"/>
</member>
<member name="M:Tensor.CudaTensor.arange``1(``0,``0,``0)">
 <summary>Creates a new vector filled with equaly spaced values using a specifed increment.</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>
 <param name="start">The starting value.</param>
 <param name="incr">The increment between successive element.</param>   
 <param name="stop">The end value, which is not included.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.arange``3"/>
</member>
<member name="M:Tensor.CudaTensor.counting(System.Int64)">
 <summary>Creates a new vector filled with the integers from zero to the specified maximum.</summary>
 <param name="nElems">The number of elements of the new vector.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.counting"/>
</member>
<member name="M:Tensor.CudaTensor.identity``1(System.Int64)">
 <summary>Creates a new identity matrix.</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>
 <param name="size">The size of the square identity matrix.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.identity"/>
</member>
<member name="M:Tensor.CudaTensor.filled``1(Microsoft.FSharp.Collections.FSharpList{System.Int64},``0)">
 <summary>Creates a new tensor filled with the specified value.</summary>
 <param name="shape">The shape of the new tensor.</param>
 <param name="value">The value to fill the new tensor with.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.filled"/>
</member>
<member name="M:Tensor.CudaTensor.scalar``1(``0)">
 <summary>Creates a new zero-dimensional (scalar) tensor with the specified value.</summary>
 <param name="value">The value of the new, scalar tensor.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.scalar"/>
</member>
<member name="M:Tensor.CudaTensor.trues(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new boolean tensor filled with trues.</summary>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.trues"/>
</member>
<member name="M:Tensor.CudaTensor.falses(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new boolean tensor filled with falses.</summary>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.falses"/>
</member>
<member name="M:Tensor.CudaTensor.ones``1(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new tensor filled with ones (1).</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.ones"/>
</member>
<member name="M:Tensor.CudaTensor.zeros``1(Microsoft.FSharp.Collections.FSharpList{System.Int64})">
 <summary>Creates a new tensor filled with zeros (0).</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>
 <param name="shape">The shape of the new tensor.</param>
 <returns>The new tensor.</returns>
 <seealso cref="Tensor`1.zeros"/>
</member>
<member name="M:Tensor.CudaTensor.empty``1(System.Int32)">
 <summary>Creates a new, empty tensor with the given number of dimensions.</summary>
 <typeparam name="'T">The data type of the new tensor.</typeparam>    
 <param name="nDims">The number of dimensions of the new, empty tensor.</param>
 <returns>The new tensor.</returns>    
 <seealso cref="Tensor`1.empty"/>
</member>
<member name="M:Tensor.CudaTensor.transfer``1(Tensor.Tensor{``0})">
 <summary>Transfers a tensor to the CUDA device.</summary>
 <typeparam name="'T">The data type of the tensor.</typeparam>    
 <param name="a">The tensor to transfer.</param>
 <returns>A tensor on the CUDA device.</returns>
 <seealso cref="Tensor`1.transfer"/>
</member>
<member name="P:Tensor.CudaTensor.Dev">
 <summary>Tensor device using CUDA GPU memory as data storage.</summary>
 <seealso cref="Tensor`1.Dev"/>
</member>
<member name="T:Tensor.CudaTensor">
 <summary>Functions for creating and operating on tensors stored on a nVidia CUDA GPU.</summary>
 <remarks>
 <p>This module contains functions for creating tensors stored on a nVidia CUDA GPU.
 It further contains functions that only work with tensors stored on a nVidia CUDA GPU.
 Calling these functions with tensors stored on other devices will result in an
 <see cref="System.InvalidOperationException"/>.</p>
 <p>The CUDA backend provides options that can be configured via <see cref="Tensor.Cuda.Cfg"/>.</p>
 </remarks>
 <example><code language="fsharp">
 let x = CudaTensor.zeros [3L; 3L]  // x.Dev = CudaTensor.Dev
 </code></example>
 <seealso cref="Tensor`1"/><seealso cref="Tensor.Cuda.Cfg"/>
</member>
</members>
</doc>
